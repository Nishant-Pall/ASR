Now that you have a greater understanding of the major design principles of object-oriented programming, you need to learn how to apply them. In order for design theories to be useful, they must be applied. Let's take a look at how to apply encapsulation. As you will recall from an earlier lesson on encapsulation, it involves three ideas. First, you bundle data, and functions that manipulate the data, into a self-contained object. Second, you can expose certain data and functions of that object, which can be accessed from other objects. Third, you can restrict access to certain data and functions to only within that object. So what does that look like in code? And what does the design look like? Before we get to the written code, let's take a look at some notation in a UML class diagram that expresses encapsulation. If you are creating a system that models a university student using encapsulation, you would have all of the student's relevant data defined in attributes of a student class. You would also need specific public methods that access the attributes. In this example, our student's relevant data could be their degree program and GPA. This would be the UML class diagram for the student class. The student class has its attributes hidden from public accessibility. This is denoted by the minus signs before GPA and degree program. These minus signs indicate that a method or attribute is private. Private attributes can only be accessed from within the class. Outside this class, instead of being able to directly manipulate the student's GPA attribute, you must set the GPA through a public method setGPA. By only allowing an object's data to be manipulated via a public method, you can control how and when that data is accessed. This control of data is like creating a gate. You only let access to data you allow. If your GPA was on a four point scale, you wouldn't want someone to be able to directly set the value to 10. Now it's your turn to describe the data and functions in a self-contained object. With every piece of essential data, you need to create a protective layer from unapproved manipulation. This is like changing a country's laws. Not just anyone can change laws the way they'd like it anytime, there is a proper procedure for changing laws. This procedure provides protection from ill-advised changes. Getter Methods are methods that retrieve data, and their names typically begin with get and end with the name of the attribute whose value you will be returning. In our example, this would be your get license ID method in the driver object. Getters often retrieve a private piece of data. Setter Methods change data, and their names typically begin with set and end with the name of the variable you wish to set. In the driver example, this would be the set car function. Setters are used to set a private attribute in a safe way. Data integrity is why you have Getter and Setter Methods. In order to change a piece of data, you need to go through the correct channels. Data must be accessed in an approved way. Let's take a look at a class that bundles data and has methods that manipulate the data. As you can see in this code, whether or not an attribute or method is private or public influences its accessibility. Attributes that are private cannot be accessed from anywhere other than from inside the class. This hides them from anything outside of the class. The only way you can manipulate the hidden data is by writing public functions that allow access to it. Now it's your turn to write some code that restricts data manipulation to certain functions within an object. There are many possible data points that are relevant to a person. The most basic of those are a person's name. In our code, you should have one private attribute that represents a person's name. This attribute can only be accessed via a public method to hide it from direct access by outside classes. Outside classes do not care how your methods are implemented. They only care if the methods are returning the expected output or doing their expected responsibility. This means your Getters and Setters do not purely have to return and change private attribute values. They can do more. Let's take a look at our student example. You might have a situation in which there are restrictions on changing the degree program. You can change your code to more accurately display this restriction when it comes to changing the degree program. Let's say that you need a GPA greater than two point seven in order to be able to change the degree program. this restriction might look like this. The outside observer does not need to know how your public methods are implemented. Just that they perform as expected. That means you can add additional code to your Getters and Setters if you need to. Overall encapsulation is meant to protect your class and its objects. It also allows for an interface of approved methods for other classes to safely use the class. It allows you to hide implementation details from other classes.