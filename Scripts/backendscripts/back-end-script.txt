Welcome to server side development with NodeJS Express and MongoDB
This is the final course of the specialization
In this course we will be concentrating mainly on the server side
We will look at how we use the Node runtime to develop server side business logic layer using JavaScript
Then we'll look at the Express framework which enables us to quickly develop a server side application
We will also look at MongoDB as a document storage for our persistent data in the database
Before you embark on this course let me emphasize that you should have a very good working knowledge of JavaScript
I expect that you have deep enough knowledge of ES 5 version of JavaScript and at least familiar with ES 2015 plus version of JavaScript specifically the use of arrow functions
Also preferably you should have completed Angular/React module of this specialization
So that you would have an understanding of the picture from the front end perspective you know what kind of data would be required on the front end in order to construct the user interface for our front end application
This understanding helps you to enable to see how our Node and Express application supports the delivery of the data required by the front end
Also how the REST API that is developed in this course will be useful to support the front end of our entire application
Now before we embark on this story I would emphasize that Web development and design can be looked at from two perspectives
First of course the design aspect of the design and development where we are looking at UI/UX design visual design prototyping colors animation and graphics and so on
This is beyond the scope of this course
In this course we are looking at developing hardcore skills for actual design deployment and development of their publications including the server side application
In this course we are concentrating on the server side development using NodeJS Express and MongoDB
This is a picture that we have been seeing over the courses of this specialization where I delineate the difference between the front end and the backend
So in this course we are now moving towards the backend the business logic and the data access layer of this entire full stack picture
So having understood what this course is concentrating upon let's look at the actual structure of this course
This course itself covers NodeJS and Node modules as explained earlier
We'll also look at the Express framework for developing server side applications again based upon NodeJS
We'll look at MongoDB as the persistent layer in our entire full stack and we'll look at how MongoDB supports the storage of data in the form of documents
We'll also look at backend as a service and look at a few examples of pre packaged backends that will enable us to quickly set up the server side for our entire full stack story
Having said that let's look briefly at the structure of the four modules in this course
Each module corresponds to one week of work for this course
In the first module we'll look at the big picture view of full stack web development
Then in case you don't know Git I will give you a quick introduction to Git
If you already know Git you can skip this and then proceed on to the introduction to Node.js and NPM
Where we'll look at the purpose of Node.js and how this runtime helps us to develop server side applications
Then we'll look at node modules and how they are structured and how they are useful the different kinds of node modules
Then this will take us on to actually examining node and how we can scaffold out a very simple server side using the HTTP core module of node
Then we will move on to examine the express framework and learn how to scaffold out a server side application
Then this will take you all the way to the very first assignment of this course
The second module primarily concentrates on the data storage side of the story in particular MongoDB
We'll quickly look at how we can use the express generator to quickly scaffold out a REST API based server
Then we'll move on to examining MongoDB understand what MongoDB is and how it supports the storage retrieval and manipulation of data
We'll look at how MongoDB can be accessed from our node application
This is essential because from within our express application we will be accessing the MongoDB in order to store and retrieve data
Then we'll look at the Mongoose object data model and understand how Mongoose enables us to define schema and model to structure our applications
Then we will look at how we will scaffold out a complete REST API server with Express and also being able to interact with the MongoDB server from our express application
This should take you all the way to the second assignment in this course
The third module concentrates mainly on user authentication
How we can allow users to register themselves authenticate themselves and then restrict access to certain operations to only registered or authenticated users or look at different category of users who can do different kinds of operations on the server side through that client side application
We'll look at basic authentication which is a very simple way of authenticating your client side
We will move on to look at cookies and how cookies can be used for user authentication
Then also look at express sessions again based upon signed cookies
We'll also look at user authentication with the passport module
The passport module consolidates and provides a comprehensive way of providing various ways of doing user authentication
In particular we will concentrate on local authentication using passport first
We'll look at mongoose population and how we can include parts of one document into another document and then automatically populate this information into a document before delivering it to the user
This should take you all the way up to the third assignment in this course
The final module concentrates on finishing up with the understanding of how we develop a server side application and also quickly review backend as a service
So in this module we'll look at secure communication using HTTPS
I will briefly review cryptography and security in the context of how it is useful to set up an HTTPS server
We'll look at how we can upload files using a Node module
We'll also look at cross origin resource sharing or costs
What is it? Why should we be aware of it? How we can set up our express server to support costs? Then we'll look at OAuth and third party authentication and how we can use OAuth for doing user authentication
In particular we'll look at an example of using Facebook for authenticating our users
Finally review backend as a service
That should take you all the way to the final assignment in this course
I hope you have a lot of fun going through the various modules in this course and develop a strong understanding of server side development using Node Express and MongoDB
Of course we would be covering to a reasonable extent so that we can quickly get started up and running but there are more issues that you can learn beyond this course
So I would strongly encourage you to continue learning further about both the server side development as well as front end development that you've seen in the previous courses of this specialization
Wish you good luck in completing this course and I hope you enjoy your journey through the various topics that we cover in this course.
Before you embark on this course let me take you through a quick tour of all the learning resources that are available in this course and how best you can make use of these learning resources to maximize the benefit of doing this course
The course itself is organized into four modules
Each module has an overarching theme that guides the design of the module
A module itself is divided into multiple lessons each lesson concentrating on one specific topic
There would be an assignment due at the end of each module
Each module typically corresponds to one calendar week of work
So this whole course could be completed in four weeks time but please take the time necessary for you to completely understand before you move on to the next module
As already mentioned each module is divided into multiple lessons
Each lesson itself is organized in this manner
A lesson starts out with a set of objectives and outcomes being specified for that lesson
Then following that you will have a set of videos that introduce you to the concepts and technologies on which this particular lesson is concentrating on
This will be followed by one or more hands on exercises that will help you to understand the concepts and technologies by doing the exercises
At the end of each lesson you will also have additional resources which will point you to resources that might be useful for the topic covered in this particular lesson
Let's take a quick tour of your course page
So as you go to the course homepage you will find a lot of details about the course there and you'll also notice that the course itself is organized into weeks
Each week corresponding to one module
Let's visit one particular module to learn how the module itself is structured
So as you go to each module you will see that the module will have a brief introduction on the theme of that particular module
Then there will be a set of learning objectives for that particular module
Following that you will have a set of lessons
As I mentioned earlier each lesson will be organized into a set of items
Let's take a quick tour of this lesson on introduction to Node.js and NPM
As you click and go into that lesson you will notice that at the start of the lesson you will have the objectives and outcomes for the lesson explicitly specified
I would urge you to take a few moments to read through this document
Because this will clearly set up the goals for this lesson and also tell you exactly what you will achieve at the end of that particular lesson
Following that you will have a set of videos that will explain some of the concepts and technologies relevant to that particular lesson
I would urge you to watch these videos first
Following the set of videos you will have a one or more hands on exercises for that particular lesson
The exercises themselves will be illustrated through a video which gives you step by step progress of that particular exercise
So I would strongly urge you to watch this video in order to understand how to do the exercise
Also in the exercise I will explain a lot of details about why each step is being performed in that particular exercise
Now in addition to the video illustration of the exercise you will also have a summary of the instructions for that particular exercise given as a separate document following that video
The objectives and outcomes for that particular exercise will be listed out
Then each step will be illustrated briefly in this particular document here
So once you watch the video you can also use this exercise instructions as a guide as you perform your own exercise routine
In addition the exercise instructions will also contain code snippets that will be useful for you to do your exercise
I would strongly urge you not to simply cut and paste this code snippets instead understand exactly what you're doing at each step and then either type in the code yourself or copy and paste the code from the instructions here
Furthermore for every video if there is a set of presentation slides those would be available in the downloads to the right of this video there on the web page
Also if you go to the additional resources that are provided for you at the end of each lesson you will also have links to the PDFs or the presentation
So there are two places from where you can download the PDFs of the presentations about the the concepts and technologies for each module
You will also have links to Node.js documentation about the specific concepts and technologies covered in that particular lesson
I will also give you links to articles blogs or additional resources from the internet that might be useful or relevant to this particular topic of the lesson
I would suggest to you to spend some time looking up these additional resources so that they may aid you in also furthering your understanding of the specific topics covered in that particular lesson
To summarize the learning resources in each lesson is organized into a set of video lectures illustrating the concepts and technologies
Then hands on exercises which include both step by step instructions in the form of a video and also written instructions for the exercises and additional resources that might be useful for you relevant to that particular lesson
Also as I mentioned at the end of each module you will have an assignment due
The tasks to be performed in the assignment will be illustrated through a video where all the tasks that you need to do in the assignment will be shown to you
Thereafter you will have a written document that explains the details of that assignment
This written document will give you access to the resources that might be required for this assignment
Following that you will have the set of objectives and outcomes for that particular assignment given to you then the requirements of the assignment will be specified in terms of the set of tasks that you need to complete and the steps for each task will be illustrated
At the end of the document you will also be given the review criteria
The criteria based on which your submission will be judged for this particular assignment
As you embark on this course let me quickly remind you of a Sanskrit Subhashita or a wise saying about learning
It goes as follows 
What this means is that one fourth of your learning comes from your teacher one fourth of your learning comes through your own intelligence as you do the steps
Use your own intellect to analyze and understand what you're doing
One fourth of your learning comes from your classmates
So this is where interacting with your colleagues that are also taking this course at the same time through the discussion forums would also help you to understand the concepts
Finally the last fourth comes only through experience or only with time
As you learn and make use of the concepts and technologies that you learn in this course you'll begin to understand more and more about this particular topic
Let me leave you with my best wishes for you so that you would get the most out of your journey through this course
Wish you all the best.
What is Full Stack Web Development?
Let me clarify to you a few terms so that we start with a common understanding of full stack web development as applied in this specialization
We often hear people talking about the front end and the back end
The front end is where we are delivering the content to the user typically in a browser where the user accesses the information
This is where we use technologies like HTML CSS and JavaScript to render the content for the user
This information delivery is supported behind the scenes by a back end support which is typically implemented these days using technologies like PHP Java ASP.NET Ruby Python or NodeJS
We often hear people talking about the three tier architecture for web development
In this approach the entire web application is organized into three different layers
The presentation layer which is concerned with delivering the information to the user
So this is usually the UI related concerns that are dealt with at the presentation layer
The business logic layer on the other hand is concerned more about the data the data validation the dynamic content processing and generating the content to be delivered to the user
This is backed up behind the scenes with the data persistence layer or the data access layer
So this is concerned with how we store and interact with the data typically in the form of a database and access this data through an API
Exploring this further let us see what is implemented typically in the traditional web development in each of these three layers
The business logic layer is usually implemented these days using technologies like Ruby Python PHP Java C++ or ASP.NET
This business logic layer is interacting behind the scenes with the persistent data typically stored in a relational database and accessed by the business logic layer
The business logic layer is also concerned with the rendering of information to the front side typically in the form of server side rendering this case
So the HTML CSS and JavaScript is generated on the server side and then sent over to the client side in the form of a web page
In this approach we need specialists in each of these three layers
So a front end specialists typically would be well versed in HTML CSS and JavaScript
The business logic specialist would be well versed in one of the technologies that is used for implementing the business logic and then you need a data specialist who will be well versed in the relational database management system
There is an increasing trend towards using a single language to implement the entire stack this being JavaScript
So you could have the front end implemented for example as a single page application using frameworks like Angular or React
You have the server side or the business logic layer being implemented using technologies like NodeJS which is also dependent on JavaScript
Then you have the data storage itself being implemented using technologies like MongoDB which stores data in the form of JSON documents
The information exchange between the server side and the client side is usually done using JSON as the format and the server side supports a REST API endpoint
We will cover all these technologies as part of this specialization
So as you go through this specialization you will see that on the presentation layer side we will cover Bootstrap 4 an Angular or React for implementing front end applications
Then on the business logic layer we will be using NodeJS and NodeJS modules and Express for implementing the business logic layer
We'll also consider back end as a service and then the data support implemented using MongoDB.
 Git is a very popular version
control system for software
We need Git for working with our node
ecosystem that we're going to use throughout this specialization
So it is important for
you to get Git onto your computer
So let's go through a few quick steps
to set up Git on your computer
And then some quick commands to enable us
to make use of Git in this specialization
I will not go into too much of details
about version control and how Git works and so on
That is beyond the scope of this course
Instead we'll just get some
basic understanding of Git
Git is as I said
a version control system
This is a software tool
that enables us for the management of changes to source
code and maintaining a version history
So as your source code evolves you will be able to check in the code
on different points of time
So that you can always have
a way of rolling back to a previous version in case your updates
to the code doesn't work correctly
There are various version control systems
that are in use in the real world
Including CVS SVN and
Git being a very popular mechanism for version control these days
Where did Git originate? Git was designed by Linus Torvalds the
person behind the Linux operating system
Git was designed as a distributed
version control system for use in Linux kernel development
And it has seen much wider deployment
in the real world these days
That node ecosystem is
very much tied into Git
And that is the reason why we need Git for
this specialization
Let's now move on to a few hands on
exercises where you will first set up Git
Then you will learn a few
basic Git commands
And then also understand how you
can set up an online repository in places like GitHub or Bitbucket for synchronizing your source code from
your computer to the online repository
This is obviously not a comprehensive
tutorial of Git but we'll learn just enough of the commands that are necessary
for use in this specialization
Let's now run through a few quick
steps to set up Git on your computer
One easy way of setting up Git on your
computer is to go to this site called git  scm.com and then download
the Git installation files from there
So when you visit this website
git.scm.com you will see on the right hand side here
a button for you to download the Git
If you want to you can go directly to
the downloads page here on the site
And then you will find the downloads for
various platforms and you can download the one for
your specific platform for installation
This is the easiest way of
getting Git onto your computer
There are other ways of setting up
Git depending on your platform
For example if you install
GitHub Desktop on your computer it'll automatically set up Git for you
If you are using a Mac and
you set up X Cord and especially the X Cord command line tools
That will also setup Git for you
On this site git scm.com
if you go to the documentation page you will notice that there is
a book here called Pro Git
You can just go on to
the Getting Started link
You will see a specific chapter
here on installing Git
So just go to this Installing Git site
and there you have more details about how to install Git
on your specific platform
So you can use any of
the methods suggested here for installing Git on your platform
This is fairly straightforward so I am not going to go through
the details of how to do the setup
Download the installer and run through
the setup to get Git onto your computer
Once you install Git on your computer
start up a command window or PowerShell if you're
using a Windows machine
Or start up a terminal window if
you're using a Mac or Linux machine
And then at the prompt
type in git   version to check what version of Git
is installed on your computer
So on my machine I have this current
version of Git installed and that is good enough for me to work with
Once we verify that Git is installed
you will configure a couple of global identity parameters
the username and email address
So that whenever Git does any
comments as you will learn later it will make use of this information
So to do that at the prompt type
git config   global user.name and there you can type in your username
The other parameter that I'm
going to configure is my email
And to ensure that this
information has been configured we can type git config   list and then it'll list out a bunch of
configurations that we have done
Some of these are automatically set up for
you but if you want to you can set them up as you require
So here I have my code
editor value set to VI which is what I use to do
a command line editing of files
So with this we have completed the setup
of Git for use on our computers
Once you get Git on your computer
it is time to go and learn Git bit by bit
Let us now explore some basic Git
commands that are very useful for us in this specialization
There is lot more to Git than
what we cover in this exercise
To get started go to your convenient
location on your computer and then create a folder named git test
Then open this folder in
your favorite editor
Here I have the git test
folder that we just created open in my Visual Studio Code
Let me add a file to this
folder named index.html
Now you can see that I have added in some
HTML code into this index.html file
Let's save the changes
now let's switch to our command line
At the command line
go to the git test folder and let's initialize this folder
to be a Git repository
So to do that add the command line
type git init
Now this folder has been initialized
to be a Git repository so this is our first Git command
that we have learned git init
This initializes the current
folder as a Git repository and when it initializes the folder
it will mark that folder as a master
This is the master branch for my Git
now let's not worry about branches and so on
we will not deal with that in this course
We will only be working with the master
branch in this particular specialization so this would be marked as the master
Now this is the initial
point of our repository the next command that we're
going to look at is git status
If you type git status in the command
line it'll tell you the current status of the folder so let's do that at
the command line and see what it shows
At the command line type git status and read the information that is
typed out on the command window
You see that it says On branch master so
that is the master branch that we are on and it says untracked files
and then shows index.html in red
On your specific computer
it may be using different colors or represent this differently but
this is what it shows on my Mac
So now this index.html file that we
have just created in this folder is now not been added
to our Git repository
So let's go ahead and
add that file to the Git repository
So to do that we say git add
and you can simply say dot which means that all the files in
the current directory will be added to what is called as the staging
area of my Git repository
So now if I again type
git status you will see that the file index.html
is marked in green and it says changes to be committed there
and then shows the file name
And then so that means that this file is now ready
to be committed to my Git repository
So the next command that we saw
was git add by using git add you can add file or
folders to the staging area
So once you add it to the staging area
then you can commit that snapshot of our folder status
to our Git repository
So that means that when
you do the git commit what this command will
do is commit the current state of our folders
into our Git repository
So all the files as they exist at
the moment once they have been staged using the git add then they will be
committed through a Git repository then we execute the git command folder
So at this point
when we execute the git command then our initial state will now
be changed to the first commit to the Git repository so
let's go ahead and do that
Back at the command prompt
let's type git commit and then we can even add
a message to our commit
So I'm going to say git
commit  m "first commit" because this is our first
commit to our Git repository
So when I do that it says okay one file
has been added to the Git repository and some other information will be
typed out onto the command window
So let's now check again git status and now you see that it says nothing
to commit working directory is clean
So what that means is that the current
state of my working directory or working folder has been
committed to the Git repository
So a snapshot has been committed to my
Git repository now I can type the next command called git log   oneline
And see that it shows a number there
an eight digit number there and it also shows the message that we put
in our commit saying "first commit"
So that is the log of all the commits that
have been put into my Git repository
So going back to our next git command we saw that git log   oneline will show us a brief
log of all the commits
If you simply type git log it'll display a lot more detailed
information about all the commits but this is sufficient enough for
obtaining information that we require
Let's now come back to our editor
here in Visual Studio Code
So I'm going to add more changes to
my index.html file so I will add So I have changed my index.html file
Now let me add another folder
under the git test folder so I will create a subfolder
here named templates
And inside this templates folder I'm going to create another
file named test.html
This is just to show you how
Git can commit entire folder hierarchy into its repository
So with test.html now there I'm just going to copy everything from my index.html into my test.html and save the changes Going
back to the command line let's now check out the status of
our Git repository and this folder
So typing git status shows that
the index.html file that we have already added earlier to
the repository has now been modified so there is a newer version
of the index.html file
Also it shows that
there are some untracked files in this folder called templates
Let's add all these changes to our
repository to the staging area
So again type git add. and then all these files will be
added to the staging area
Again checking out the status you now
see that the changes that have been added to the staging area so all these
files have been added to the staging area
Let's do one more commit so
I would say git commit  m "Second commit" and then
let's check out the log
If you check out the log
you'll now see that there are two commits in my Git repository
the first and the second commit
And note that each one of them is
given a different number there
If you want to see the full details of
the log you can type simply git log
And then you will see
more details in there than what you would be interested in
So notice that the one line commit only gives the first few characters
of my commit number there
That is sufficient enough for
us to operate with
Let me now go back again to my
Visual Studio and add one more One more line to my index.html file
So now my index.html file has been
modified and let's save the changes
Going back to the command line doing git status shows that
the index.html file has been modified
So let's add this to the staging area and then do a third commit
so let's say git add . git status
Now you'll see that the index.html
the modified version has been added
Now we can say git commit "Third commit" And do git log   oneline and you'll see that there are three
commits in our repository
So now our repository contains
snapshots of three different points at the end of the first commit
at the end of the second commit and at the end of the third commit
Now we also can roll back changes we can revert the repository
to a previous version
We can pull out a file
from an older commit and then replace the existing file in
our directory from the older commit
So let's see how we can operate
with these things by learning a couple of more commands
At this stage our index.html
file is in the current state so you can notice that it has an h1 and
two p's
Let's now look at the next Git command
The next Git command that we're going
to learn about is git checkout
So this checkout command
allows us to check out a file from a previous commit
in our Git repository
So if we don't like the current
file that we have in our folder and we want to go back to
a previous version of the file
We can always check out the file
from a previous commit or from the current commit and
then continue to work with that file
So let's make use of this and see some
further changes to our Git repository
Going back to our command line
we remember that between the second and the third commit
I made changes to my index.html file
Suppose I want to revert back to
the index.html file from my second commit
So then I can simply say
git checkout 900cfcf so that is the commit identifier the number that identifies
that particular commit
And then I can say index.html
and what you would notice is that all the file will now be checked
out into my current working directory
Going to my Visual Studio Code you now notice that my index.html file
has reverted to the previous version
So the change that I made before
the third commit is now gone
So my index.html file has been restored to
its state at the end of the second commit
Now at the command line
if I type git status you notice that this index.html file which has reverted to what it was
at the end of the second commit
It has now already been staged
so using this git checkout will pull out an older version of the file
and then replace what is in the current directory and then it will also
check it into the staging area
So now if I do that and
then I realize that this is what I want I can simply do another
commit at this point
And then that file can be
committed as the fourth commit but suppose I don't like this
I want to revert back to
the index.html file at the end of the third commit
then all I can do is say git reset HEAD and index.html
So at this point
what happens is that the index.html the modified version that I have
checked out is still there but this file has been unstaged
from the staging area
If you go back and
look at the index.html in your Editor it will still show the state
at the end of the second commit because we had pulled out that
file using checkout for that
Now if we want to revert it back to what
it was at the end of the third commit then we do one more checkout
from the third commit
Going to our command window
type git status and you would notice that the index.html
is marked as modified
But it also shows this particular
statement here it says git checkout    and the file name to discard
the changes in the working directory
So that's one way you can
discard the changes that are made to a particular file
corresponding to the previous commit
So let me restore this
index.html back to what it was at the end of the third commit
So to do that
I will simply say git checkout    index.html and then if I do Git status it shows that my
directory is clean and basically my directory has been restored to the state
of the end of the third comment
Going to the file in my Visual Studio
Code I see that the file has been restored back to what it was at
the end of the third commit
So if you have made changes to a file
after a commit and you want to just discard those changes you can simply
checkout the file from the last commit
And then all your changes that you've done
after the last commit will be discarded at this part.
So these are some basic commands
that are very useful for you as you go through the courses and the specialization because you may want
to commit at the end of each exercise
And as you proceed forward you would still have a committed
version of the state of your folder at the end
of the previous exercise
So that way if you are carrying out a new
exercise and you discover that you've made mistakes and you want to
revert back to the previous commit
You'll always have a way of
doing that using the commands that we have just learned
So with this basic understanding
of these few Git commands we would be able to proceed
forward with understanding and using Git in the courses
of this specialization
So now we have reviewed the git reset for
a specific file or git reset in general
If you simply type get reset
it'll restore you back to the last commit
So it will reset the staging
area to the last commit without disturbing the changes that
you've done to your working directory
So once you reset
then you can checkout the previous version of the file that you have
committed in the previous commit
So this way you can restore your
folder back to where you were at the starting point
of the previous commit
So sometimes when you are going through an
exercise and you realize you made mistake you always have a way of reverting
back to a previous version
So with these commands I think
you're all set to go ahead to use Git in the courses of this specialization
So at the end of this exercise
did you Git it? 
 Online Git repositories
enable you to store a copy of your Git repository online
And it can easily be shared among
multiple computers and multiple users
Let's learn about two of the online
Git repository service providers GitHub and
Bitbucket in a little bit more detail
We'll look at how we can setup
our local Git repository to be mirrored in
an online Git repository
There are several online Git
repository service providers
Two of the most popular ones
are GitHub and Bitbucket
I will go through in more detail about how
you can setup your Git repository that you prepared in the previous exercise to be mirrored on an online Git
repository on Bitbucket
To set up an online Git repository go to one of these online service
providers and then sign up for an account
So here I have signed up
into my Bitbucket account and I have my home page open here
And so I'm going to create a new repository online on my
Bitbucket repository
So I just clicked on it
create repository and then this would come up with some details
Now this varies with
the repository service provider
So here I will specify the name of
the repository and and skit test
And I'm going to mark this
as a private repository
For this course and all the remaining
courses in this specialization I would strongly advise you to keep your
repositories as private repositories because you don't want somebody else to
be copying a code that you might save in your online Git repository
So please make sure that you only used private
repositories in this specialization
So I will sign up as a Git
private repository and then simply click on Create repository
And then it will do some set up and
then be ready for me okay? Now what I need to do is to copy this
particular URL format repository
So you will see URL for the repository
in the Homepage of that repository
So just copy that URL for the repository because we would need that in
order to synchronize our local Git repository with this repository
so I'm going to copy that
And since I have already created my
local Git repository I'm going to go in there and set that up to be
mirrored in this online Git repository
So for that we need to use a couple of
Git commands that enable us to do this
Going to the command prompt
in my Git repository folder I will type git remote add origin
And then paste the URL for
my Bitbucket repository that I have just created
and Hit the return
So now my local Git repositories remote
origin is set to the Bitbucket repository
So now
I want to be able to push the entire contents of my local Git repository
to my online Git repository
So reviewing the commands for
setting up the online Git repository the first one that we just did Git
remote add origin and the repository URL
And so this will add the online
repository as the remote repository for my local Git repository
Once I do that then I need to push
my contents to my online repository
For that
I'll do Git push u origin master
And this command would push the local
Git repository to the online repository
So let's type that
add the command prompt
So once I typed this at
the command prompt and hit the Return
it's going to setup my Git repository
Sometimes it may ask you to
type in your credentials including your password on your Bitbucket
account so you may have to do that
I had already done that previously so
that's why it didn't ask me again for the password
But once I've typed that in
then the contents of my local Git repository will be pushed
to the server side
So now the data on my local Git repository
is now matched of the server side
So let's go to Bitbucket to see the status
of my online Git repository now
Going to my Bitbucket and
then reviewing the online Git repository you would see that there
has been a branch the master branch that has been
pushed to my online Git repository
I can then examine the source
by looking at the source here
And then you can see that I have the
index.html file which is exactly the same as what I have in my local Git repository
and examine the various comments also so I can look at the state in the second
comment and the first comment
So you can now see that all this
information has been uploaded to the online repository
including the history of all the comments
Then going back there
you can see more details about all the comments that have been
sent to the server side
I can examine each of those
comments in a bit more detail
And I'm going back to that source I can look at more details
of the source like that
So that has now set up my local Git repository to be mirrored in Bitbucket
The procedure is pretty much
similar even on GitHub
So let me set up an online
GitHub repository
Obviously you have to remember that
your local repository can only be matched to one online Git repository
So I will only go to setting up the
repository on GitHub and you will notice that this same kind of commands will
be required if you want to set up your local repository to be
mirrored on a repository on GitHub
So on GitHub
if you log in to your account you would see something
like this in your Homepage
You can go to the right hand side
where there's a plus sign and then click on that to
create a new repository or just click on this button
here to save your repository
And then when that comes up
I can simply say git test and then again as a reminder
please make the private repository
Most of these providers allow you to
now store private repositories online
So why make them public unless you really
want to share it with other people
So I would strongly urge you to
keep your repositories private for the moment unless if you're
working with a team
I should remind you that at this moment
GitHub supports private repositories only for those subscribers who pay for
their GitHub account
So it is not available for subscribers
who are using their free account
So simply click on Private
and then Create repository and then that will create a repository
And then you would see that GitHub also
gives me a bunch of commands here on how to setup the repository so for creating
a new repository on the command line
The commands that we actually had done
earlier or to push an existing repository the same two kinds of commands
that have to be issued
So that basically sets up
your GitHub repository to mirror your local repository
So since I have already linked
my repository to Bitbucket I'm not going to use my GitHub
repository for the purpose
So as you notice the procedure is pretty
much similar on either one of them
Give and take a few differences in
the way the information is rendered on the screen in the user interface and
a little bit of changes
More or less they are similar in the way
you're going to make use of them in terms of mirroring your local Git repository
to the online repository here
So with this suppose somebody
gives you a Git repository can you make a copy of
that onto your local one? So this is where we use another
Git command called Git clone
So now here you see that I
have this git test repository
So what I'm going to do is I'm
going to go to the repository and then copy this URL
And then I'll show you how I can
create a copy of the Git repository or clone this online repository
into my local computer
So let's pretend that I am on a different
computer and then we'll go to our command line and then create another
repository with that same name
Going to my command line
I'm just going to move up into my and you'll see that I have my
git test folder there
So I'm going to create another
temporary folder here just to show you that I can
clone an online Git repository
So in my temporary folder
you'll see that it is empty
So to review the command it says
Git clone and the repository's URL
So let's apply this command and
then clone that online Git repository
Pretending that we are on another
computer so I'm going to say git clone and then Paste the URL of my Bitbucket repository here
And then you would see that Git
repository will not get cloned into a local folder with
the same name git test
So now
if I do a listing of the directory you can see that the git test
folder has been created
So let's go to the git test folder
and then you will that this is an exact copy of the folder
structure that we had created earlier
So this is how you can clone
an online Git repository
So all you need to do is to obtain
the URL of that Git repository and then simply use Git clone to get a copy
of that onto your local computer
With this we complete this exercise
on using online Git repositories
So did you finally get it? 
JavaScript which was designed as a scripting language for the browser has seen deployment far beyond the browser
Node.js has played a significant role in this shift of JavaScript from the browser to the desktop
Let's now learn a little bit about what Node.js is and what role does NPM the Node Package Manager play in the context of Node.js
Node.js as I mentioned earlier allows us to bring the power of JavaScript to the desktop
Node.js is based on the JavaScript runtime engine that has been built for the Chrome browser
So the Chrome V8 JavaScript Engine has been ported from the browser to run on the desktop and support the execution of JavaScript programs on the desktop
Node.js is built around an event driven non blocking I/O model which makes it very efficient to run JavaScript programs on the desktop asynchronous JavaScript on the desktop
Now this is where node finds its true pouch
This is the typical architecture of Node.js
So in this the Chrome V8 engine is at the bottom layer together with libuv forms the layer that interacts with the underlying computer system to support the execution of JavaScript programs
On top of it we have node bindings which will also implemented in C++
At the top layer you have the Node.js and Standard Library which are all implemented in JavaScript and this is what enables us to write JavaScript programs and run them on the desktop
Naturally the ability to run JavaScript programs on the desktop energize the web development community to explore using JavaScript to develop a significant number of web development tools
Tools such as Bower Grunt Gulp Yeoman and many others
This course in this specialization as I mentioned looks at the use of Node.js on the server side how we can develop web server business logic all implemented in JavaScript
Together with node you often hear people talking about the Node Package Manager or NPM
When you install Node on your computer NPM automatically gets installed
The Node Package Manager is the manager for the Node ecosystem that manages all the Node modules and packages that have been made publicly available by many different users
A typical Node package consists of JavaScript files together with a file called package.json which is the manifest file for this node module
We will look at how we can use the package.json file in more detail in the subsequent exercises.
It's time to install Node.js on our computer to get started with this course
So without further ado let's head over to nodejs.org and then download the latest version of Node.js suitable for our computer
Heading over to nodejs.org we notice that we have two versions of Node.js available for us
I'm going to download the latest current version of Node.js the stable version
Once the installer is downloaded double click on it to proceed ahead with the installation of Node.js and it should bring up an installation screen which might look like this depending on the specific platform on which you are installing Node.js
So the rest of the course is going to depend upon these versions of Node.js
Continuing with the installation
Once the installation is completed then you can verify the version of Node.js by typing node minus v and the prompt and check the version of node and similarly npm minus v at the prompt to check the version of npm that has been installed on your computer.
 In this lesson we will learn about
how we can write simple notifications
We'll also learn about Node modules and how Node modules enable us to organize
our applications into multiple files
We'll also learn about the different
kinds of Node modules and how we can import Node modules into
our files of our Node application and make use of them within our application
First let's learn about Node modules in
a little more detail in this lecture
JavaScript when it is first designed was meant to be a scripting language
to be used within the browser
So the small realm within which it was
supposed to be used is the browser
Now as you understand from this
specialization JavaScript has gone way beyond its original intention and now
is being used for writing applications
Both to be run using frameworks
within the browser and also to run applications on the server
side as we will see in this course
JavaScript originally was never
designed with any common libraries
If you look at standard programming
languages like C C++ Java and so on they all have standard libraries
that enable you to access the underlying hardware
And also provide a structured way of
organization the application into multiple files and then combining them
together when you create an application
JavaScript never had any of
this support when it began
Because as we understand
JavaScript was not designed for the purpose for
which it is being used today
But of course people understood the difficulties
when you need to expand JavaScript beyond a single file which is used as
a scripting language for the browser
Now if you have a very large
JavaScript application it becomes cumbersome to write
the entire code in one single file
And obviously you want the results to
be able to break your application into multiple facts
Now unlike traditional programming
languages JavaScript never had a way of distributing the code into multiple
files and then combining them together
So this is where the CommonJS API
came in to fill in this gap that fills in the needs for
some common application
And this CommonJS format defines
a module format that can be used for breaking up your JavaScript
application into multiple files
And Node adopts that CommonJS format for organizing our JavaScript
application into multiple files
And within JavaScript
with the CommonJS format each file becomes its own Node module
So let's learn a little bit more about
Node modules in the rest of this lecture
So as I just mentioned each file in a Node application
becomes its own Node module
So the file or the JavaScript file
defines the boundary for a Node module
So within that file
the CommonJS specification provides a variable called the module
variable which is a JavaScript object
And this gives you access to the current
module definition within a file
And on this module object
you have the module.exports property which determines
the export from the current module
So when you assign something to
the module.exports property then that becomes the exported
value from the current module
So that when this module is
imported into another file of our Node application
then whatever is exported from this module becomes available in
the second application
We'll look at an example in short while
When you need to import
a module into another module this is where the require function
is used to import the module
So as we will notice in a short while
the require function is used to import a Node module that is defined
in other file into the current file so that it can be used within
our node application
Node modules can be of three categories
We have file based Node modules where we
define the Node module within a file within our application and
we make use of it within our application
Then we have core modules
that are already part of Node
The Node designers kept these core
modules intentionally small so that Node can be kept small
And also provide sufficient
functionality so that external module designers
can add in their own functionality that can be leveraged
when we developed Node applications
So the core modules include path
file system os util and a few others
We will encounter some of them
as we go along in this course
Then we have external Node modules
These are third party Node modules that
are developed by Node developers and then made available through
the Node ecosystem
So these external Node modules can be
install within our system using NPM
So many times you would see
us using NPM install and the name of the Node module and
that will be included within our Node application in a folder
named node_modules folder
And we will encounter external Node
modules in a later lesson in this course
How do we make use of Node modules? When you need to use a Node module within
another Node file within your application then you would use the require function
I briefly mentioned about the require
function in one of the previous slides there
The require function for
file based Node modules you will specify this as require and then specify the path to the file
which contains the Node module
So you would say require./
the module name if the file exists in the current folder written
which your Node application exist
So this specify the relative path to
the file from the current location
And also for the core and
external modules you would normally specify them by saying
require and the name of the module
You would explicitly specify a path for
it
If it is a core module
it's already part of Node and so it will be automatically included
If it is an external module
then it will be installed either within the node_modules folder in the current
folder or if the Node doesn't find the external module within the
node_modules folder in the current folder it will go up to the next higher level
folder looking for that Node module
Or the next higher level folder and up the hierarchy until it locates
the Node modules which will then be imported to be used
within your Node application
If it is unable to find the Node
module up the hierarchy then it'll obviously raise an error
saying that the Node module is missing
This way of organizing is
very useful in the way the Node application structure
is defined as we will encounter more in the later part of this course
With this quick introduction to Node
modules let's take a look at an example which we will do as part of
the exercise that follows this lecture
As we learned in this lecture a Node module's boundary is defined by
the file that contains the code here
So here I have an example of a Node
module defined as rectangle.js
And in there you can see that
I am using two exports here I'm saying exports.perimeter and
exports.area
And you'll see that here I'm not
using module.exports because exports itself is also a shortened
version of module.exports
So if you don't want to use
module.exports completely but instead just want to exports
then this is another way of writing those items that are exported
from the current Node modules
So here we are exporting two functions
the perimeter and the area from the rectangle Node module
Now in order to make use of
this module in another file then let's take a look
at the index.js file
And the very first line in this
file you will notice that it says var rect = require and
within quotes ./rectangle
So this is specifying that the rectangle
module is going to be important in here I made use of within this
particular file of the application
So this is how we would
define Node modules and this is an example of
a file based Node module
We will encounter the core and the external Node modules in
later lessons of this course
Now that we have an understanding of node
modules let's do our first exercise to further our understanding of node
modules with an example in this exercise
So to get started let's go to
a convenient location on our computer
So here
I am in my documents Coursera folder where I have the files from
all the previous courses
So I'm going to create a new folder here
named NodeJS and this folder is where I'm going to store
all the code related to the NodeJS course
So going into the NodeJS folder let's create a subfolder here
named node examples
And in this folder we're going to be creating
the files related to this exercise
Open a terminal window or
a command window and then navigate to the node examples
folder at the prompt and then at the prompt type npm init to initialize this folder
as a node application
So type npm init and
then it will come up with some standard default values for
some information that is going to store in
a file named package.json
So for the name let's type node examples and version is 1.1.0 and description I'll simply type Simple Node Examples
And the entry point is
index.js default value
For the test command just leave it as such
and the Git repository for the moment we'll leave it as such
And for the author
just fill in your name
And the rest and then npm init will show the default value that it'll set
up in the package.json file
So as we have learned the package.json
file is the manifest file for a node application and once you
complete this you will notice that the package.json file is created
in that node examples folder
Let's open this project in
an editor of our choice
So I'm going to open my
Visual Studio code at this folder
When my Visual Studio code
it opens in that folder
I'm going to go to the scripts here and
set up a script here saying "start" and I'll say "node index"
And then save the changes
to the package.json file
Next I'm going to create a folder here and
name it as index.js and as you realized that main here
is given as index.js file so that starting file for
my node application
So in the index.js file
I'm going to create a simple example to illustrate various features of node and
how we will construct node modules
So here we'll construct an example
that evaluate the area and the perimeter of a rectangle
A very simple example that
it helps us to illustrate various aspects about node and
node modules
So the get started type Var rect
And we're going to create
a JavaScript object here that's two properties
perimeter which is a function
And as you see I am using the arrow
function to define this function here
So node in its current version
supports ES 6 or ES 2015
And so that is why I'm going to
use the arrow function support that is available in ES 2015
to define this function here
And if you have taken the previous
courses where we use time skirt this would be quite familiar to you
Now with node we have the option
of using JavaScript or Typescript
Now the documentation for node and also express that we will see later
all use standard JavaScript
So I have defaulted to using standard
JavaScript in this course or ES2015 JavaScript in this course
If you prefer to use TypeScript you can set up your node examples to
write your application in TypeScript
But then you will have to transpile
that code into JavaScript so that it can be run using Node
So you have to set up
additional infrastructure in order to be able to use TypeScript
In this course I am going to use
JavaScript as the default language for the rest of the course
And I'm not going to go into
Typescript use it in this course when nodes start supporting
Typescript natively then it makes more sense to
move to Typescript 
But if you are interested in Typescript I have noticed that there have been
several blog articles posted by different people that illustrate how you can set up
your Node application to use Typescript
Having said that
let's return to the index.js file and then continue with our example
So I'm setting up a perimeter here and
then also an area function here
Again taking two values x and y which represent the length and
the breadth of the rectangle
The two parameters and
the area is computed as x times y
So from your primary school mathematics you know how to compute the perimeter and
the area of the rectangle
So here I have set up this
JavaScript object here and then let me define a function
here named solveRect which takes two values (l b) as the two parameters the length and
the berth of the rectangle
And it is going to use this
JavaScript object that I have defined earlier in order to compute the perimeter
and the area of he rectangle
So inside here let me do a console.log and say Solving for rectangle with l equal to This is just for our convenience
So that will print out this information
onto the terminal there and so in this console.log I'm just
printing out the l and b values so that I know for the rectangle for which we
are computing the length and the breadth
Now I'm going to check to
make sure the length and the breadth are not less than or
equal to zero
If they are less than or equal to zero
then it doesn't make sense to compute the Perimeter and area for the rectangle
So I will say console.log here so I would say Rectangle dimensions should be greater than zero
So that way we print out these values
on to the screen if the length and the breadth are less than or
equal to zero
Otherwise of course it makes
sense to compute the perimeter and the area of the rectangle
So we'll say else console.log("The area of the rectangle is")
Similarly we'll compute The perimeter of the rectangle
Here
So inside this function
we are computing the area and the perimeter of the rectangle and
purging it out
Now we obviously need to call this
function using different values for length and breadth and
see what it prints up
So right below here
I'm going to say solveRect and then just use some values here
So I'll say 2 4 And 3 5
And let's say 0 5 and see what happens
And  3 5
So four different choices
of parameters here to illustrate how this
application is going to work
So with this let's save the changes
Now going back to the terminal
at the prompt type npm start and you would see that it prints out
the area of the perimeter for the different rectangles that
we have specified there
So we are saying solving for
the rectangle with l is equal to two and b is equal to four and the area of
the perimeter for this rectangle
And for the second one and for
the third one as you see your dimensions should be greater than zero and
for the fourth one also
it is printing out the same value
Now obviously I notice that I would
need a space there so I'll just correct the code to add in that extra space there
So with this we have seen how we
can write a simple node application to compute the perimeter and
the area of a rectangle
Now obviously you want to be
able to set up a Git repository where you can store all this code
So at the prompt type git init to
initialize the Git repository and then you can check the status
of the Git repository and you notice that two files
have been newly created
So let's add the two files
to our Git repository and at this point checking the git status you see that
the two files have been checked in
So let's do a git commit break the message Simple Node Example
In the second part of this exercise
we're going to now create a node module in this example
So at the editor in the editor create a file named rectangle.js
And inside this file
we're going to create a node module
So we're going to use the exports object in order to export the two values from this node module
So as you've learned every file in a node
application becomes its own node module
So from within this rectangle node module I'm going to export two values
the perimeter And The area
Now I"m going to go into index.js file and
then simply copy this value
And that is what we will
use as the export for the perimeter here and similarly for the area I'm just going to copy this from the index js file and
then use that for the area
So now we have a simple node module
ready which is exporting two values the perimeter and
area from this rectangle.js file
So as we have learned in the lecture
 node modules now once you create a node module
you need to input that node module into another file where you
want to make use of it
So going back to index.js file
Now I'm going to replace this
whole thing by require and I note that this node
module is in the same folder as the current project
So I would say require rectangle and
that's it
So my changes are now complete
So this particular index.js file
is going to import the rectangle node module that we have just created and
then make use of it within our code here
So let's save the changes and then take a look at our application again
at the terminal prompt
Going to the terminal
at the prompt type npm start
You will notice that there modified version of this application produces
exactly the same results as before
With this we learn about how
you can create a simple node module in our application
Now checking the git status
you'll see that you have two files one which has been modified
another one which has just been added
So let's add this to
our Git repository and then do a git commit with the message Simple Node Module
And Check the git log and you'll notice that we
have two commits that we have committed to our
Git repository there
With this we complete this exercise
In this exercise we have seen how we
can write a simple node application
And also how we can write
a simple node module and use it with another file
in our node application
A discussion about Node Modules is incomplete without talking about Callbacks and Error handling
What are callbacks and why are they essential for supporting asynchronous computation that is very useful when we write Node.js applications? How is error handling done in Node applications? Let's talk briefly about these in this lecture
Before we proceed on to talk about Node Modules and Callbacks we need to understand two salient features about the JavaScript language itself
First and foremost JavaScript supports what is called as first class functions
What do we mean by first class functions? Is that a function can be treated just like any other variable
And hence functions can be passed around as parameters inside function calls to other functions
And that essentially allows us to send in functions as callback functions that can be called from another Node module in order to get some work accomplished
Then look at how this is very useful in supporting callbacks in Node.js
The second aspect about JavaScript is the support for Closures
What we mean by Closures? Especially if you are familiar with functional programming languages you understand how closure works
A function defined inside another function automatically gets access to the variables that are declared in the outer function
So even if the outer function is completed execution when the inner function executes later the inner function will still have access to the values of the variables within that outer function
And this is again very effectively used when we use Callbacks in Node applications
If you are used to the standard way of writing applications then you are familiar with synchronous computation where you specify a computation as a set of steps to be done one after another
Now if you organize your computation as follows as shown on the left side of the slide here we have computation one then followed by a long running computation followed by computation two and computation three
So in this arrangement let's assume that computation two is dependent upon the long running computation completing its work then it makes sense for computation two to wait until the long running computation is completed before it gets executed
Now we might have another piece of work to be done which is defined by computation three
Computation three may be in noway dependent upon computation two or the long running computation to complete before it is executed
So in this case if we do synchronous execution of this computation then computation three will get stuck even though it is no way dependent upon the completion of either computation two or the long running computation
So thereby the amount of work to be done by computation three will be delayed because of no reason of it's own right? Instead is delayed because of something that precedes it in the sequence of computation
Now asynchronous computation we can rearrange this work in such a way that computation one when it completes can spawn off those long running computation to be done behind the scenes independently and since computation two is dependent upon the long running computation to finish then computation two can be executed when the long running computation is finished
Now this frees up computation three to continue on right after computation one finishes
So this way of arranging ensures that computation three will finish much faster than being stuck behind the long running computation and computation two
So this approach of rearranging your work is very useful especially when you have a long running computation especially I/O bound computation to be done
So in this case you can spawn off the I/O bound computation and when that completes then whatever needs to be done thereafter can be sent to it as a Callback
So computation two will be turned into a Callback and then given off to the long running computation
So when that completes its work then it'll call back the function that is enclosed inside the callback
So this is leveraged very effectively by Node.js in rearranging the computation within our Node applications
Now this is very very useful when we look at the way Node.js itself runs
So as we realize Node.js is organized into a single threaded event loop
This single threaded event loop basically picks up requests as they come in and execute it one after another
Whenever it needs to spawn off an I/O request the I/O request will be spawned off and any work that needs to be done after the I/O request is completed will be enclosed inside a Callback
So when the I/O request completes then it'll put the Callback into the request queue and the Callback will be handled thereafter by the event loop
So the event loop is a continuously running loop which basically picks up requests from the request queue and then services them one at a time
So when you think back about it you realize that Node.js is a single threaded but at the same time it is able to achieve much faster rate of completion of work simply because of the judicious use of callbacks and the asynchronous execution of I/O requests like for file accesses or database or long running processing that can be done independently behind the scenes
Now the way the Node.js event loop handles all this is that the event loop is arranged in a sequence of phases
So as you see in the diagram shown here the phases include timer handling I/O callback handling then you have idle prepare then the poll where the incoming requests for connections or data are handled and then the check phase and then finally the close callbacks phase
Now some details about what is done in each of these phases is listed to the right side
In the timer phase the event loop handles anything that is triggered by the setTimeout() function in JavaScript
The I/O callbacks are executed almost all the callbacks that come back to be executed after an I/O request will be handled by the I/O callbacks queue
So each of these phases maintains its own separate queue and the Node.js event loop picks up requests from each of these queues and handles them
The idle prepare is meant for internal use by Node.js
The poll is where it retrieves new I/O events to be handled and perhaps the requests coming in from outside
The close callback phase handles any socket closures that need to be handled and so on
Now we don't need to worry too much about all these details if we need to really write a Node.js application
When required we will look at some of these details as and when it is essential for understanding how our Node application works
But for the moment this gives you a big picture view of how the Node.js event loop is handled
Sufficed to say that this is sufficient enough information for us to understand the Node applications and how they work for the moment
If you want to know more details then I have given you a link to a detailed description in the Node.js documentation which explains about the event loop in more detail
With this quick understanding of Node Callbacks and Error handling we will move on to the exercise where we will look at how a Node application can written with Callbacks and how errors can be handled inside a Node application
We will see repeated use of this pattern in subsequent exercises and subsequent lessons specifically when we look at Express and how we build server side applications using Express in more detail in the later part of this course.
In the previous exercise we learned about two new aspects of JavaScript their support for first class functions and closures
We also saw how Node handles the asynchronous programming aspect and how Node supports asynchronous execution of code with the use of callbacks and also error handling
Let's look at an example of how we make use of this within our Node application in this exercise
Continuing with where we left off in the previous exercise now I'm going to go and modify the rectangle Node module so that it can take the help of callbacks
So I'm going to remove these exports here and instead they're going to modify this function
I'm going to be making use of these two functions a little bit later so that's why I'm saving them at the bottom
So let me keep them aside
And then I will modify this rectangle module as follows
So we'll say module.exports
So we're are using the standard way the module is handled
And this is going to export this function which takes these three parameters x and y and callback
The callback is a function that is going to be supplied in when this module is called
So this is the use of the first class functions that we have talked about earlier
So inside this callback so you can see that you're getting two parameters x and y
In this case for the rectangle the x and y correspond to the length and breadth of the rectangle that is being passed in as the two values
So inside here we're going to check to see if x is less than or equal to zero or y is less than or equal to zero
We have written code like this here
So I'm just going to copy this code from here and then bring it over to here and then we'll edit
So in this case this is if x is less than or equal to zero or y is less than or equal to zero
In this case what do we do? In this case we notice that the dimensions of the rectangle are less than or equal to zero
So we have to handle it differently and we'll do the else part of it
The else part where we handle the situation where the rectangle is a valid rectangle
So in this case what we will do is to then use a setTimeout
So here I am simulating the fact that whatever is being done in this rectangle is going to take some time
So this is the asynchronous processing
Now since I don't have a lot of work to do in the background so I'm going to simulate that by simply using the setTimeout function of JavaScript and then delay before the callback function is called
So the way I arrange this is as follows
So inside the setTimeout I'm going to call this function there and arrange a delay of 2000 milliseconds or two seconds after which this function is going to be called
So if you recall the setTimeout that is supported in JavaScript it takes as the first parameter a function and the second parameter would be the time period for which this is going to be delayed
So let me indent this in
Now I need to fill in this function here
So I have started out with the arrow function here which takes no parameters and then when there is called I'm going to issue a call to the callback
This callback is a callback function that is going to be passed in as the third parameter here
This callback function as you noticed takes two parameters
The first one is the error and the second one is the return value
So in this case since we have an error because x is less than or equal to zero and y is less than or equal to zero so the first value I'm going to pass in as new error and this error is exactly this string that I was using in the console.log then and that is what I will pass in as the error here
Let me now delete that console.log I no longer need it
So for the callback I'm going to generate a new error object and then pass this in as the return value for the callback function the first parameter
So I'll say rectangle dimensions should be greater than zero
So we'll say l this is the x and the y value that we got as the input values there
So that is the callback
And the second part of this callback I'm going to pass in as null because this is going to return an error
So when you return an error as the first parameter the second parameter will be ignored when that callback was just received by the node module from where we are calling this particular function there
So with this arrangement so less than zero so let me give some space here so that it's properly indented here
So the way I am arranging this here is that if x is less than zero and y is less than zero I'm going to callback the callback function that has been passed in but the first parameter will pass in in error because here we notice that there is an error and the second parameter will be null
If this is not the case then I'm going to call the same callback but with the first parameter
So let me copy that code in here
I'm still going to use the setTimeout here
But that first part is not going to be an error instead the first part in this case there is no error
So I'm just going to pass back that value as null
So that means that the error is set to null
So this is a valid rectangle
So we can compute the values for the rectangle
But instead I'm going to simply pass in a JavaScript object containing the two functions as the two values inside this JavaScript object
So here I am going to take this two the perimeter and the area and then these two will be passed in as the two values here perimeter and the area
And these two since they happen to be a JavaScript object so perimeter and area will be the two properties that I will pass in inside those JavaScript object and that is it
So here in the second case the error is set to null because there is no error but the second part notice that I am passing in a JavaScript object containing two properties perimeter and area which are two functions here
So the two functions are the perimeter function and area function
So this JavaScript object will be passed back as the return value for the callback here the second value
And again I am going to delay this by a two second interval before the value will be passed back by this function
The reason why I'm using the setTimeout is to simulate a delay before the callback comes in from the other side
So this sort of represents situations where for example you issue a database call to the database and the database needs to be read before the value is passed back to you
So that is going to take a certain amount of time
So I'm basically simulating this at this moment by using the setTimeout function here
Later on you will see that when we integrate the MongoDB with our Express in the later exercises that delay would have to be simulated it'll be automatically caused because of the fact that you need to do database operations behind the scenes before the data is obtained
So here having completed this rectangle modules update so here you see that the rectangle module takes in three parameters as it's a input call here x y and callback
And so the callback is the callback function that is being supplied here
And this callback function will be called inside here and when the callback function is called either you pass back an error or you pass back a function that allows you to compute the perimeter and the area of the rectangle
Now this pattern of calling in and passing in a callback function from one Node module and then the second Node module which when it completes will pass back the result using the callback function is exactly the pattern that you will see often repeated in Node applications
So that's the reason why I'm illustrating it
Of course this is a contrived example that I am illustrating here but it shows all the standard patterns that you will use with node and callback functions and also the error handling
Now we have updated the rectangle module here
Let's go and fix that index.js file so that it can pass in the callback function and then handle the return value that is sent back from the rectangle module
Switching back to index.js now we are going to update the index.js file as follows
I'm going to remove this from the index.js file instead
Here what we will end up doing is call this rectangle module and then pass in the l and the b as the two parameters
And the third parameter that I'm going to pass in is that callback function
So the callback function has two parameters err and rectangle
And this callback function is implemented as follows here
So here you see that I'm calling this rectangle node module and I'm passing in the length and the breadth of the first two parameters
And the third parameter is of course a callback function which I'm implementing here
So this is an arrow function that I'm implementing here
So inside this callback function how do I handle the return value? So here I'll say if (err) so if the error value is returned to you then I will simply do console.log and I'll say "ERROR" and then the second value is err.message
Recall that in the rectangle we had created this new error object and then passed in this string inside this error object
This string will be attached to the error object to the message property of the error object here
So in the index.js file so I'm retrieving the message property of the error object and then printing it out onto my console here
So if an error occurs I'm going to print out the error message using this
And so this is how I would handle error that was returned by a callback function
Otherwise of course in this case the rectangle module has returned the rectangle function the object that contains the perimeter and the area functions so I can go ahead and print out that value
So here I'll say the area of the rectangle of dimensions l equal to so I will say and b equal to
The reason why I am identifying it explicitly will become very clear when we run this example
I'll say is rectangle.area
Now notice that for this area I am not sending in any parameters here because goes to values the length and the breath have been passed in already here in the l and b and those would be already available to this and here because of the closure that JavaScript supports
Because these x and y have come in as the parameters so those will be accessible right there in this callback function
So those x_y will be automatically available for us here
So as a matter of fact I don't need to supply this x and y parameters here at all because those x and y will be retrieved from this x and y right there
So I don't even need to pass those two values in here
So that's why right there I can call rectangle.area
And this area computation will automatically get the l and b that have been passed in by the rectangle call to direct node module earlier
So this is the closure of JavaScript operating here
So that is the first one
I am printing out the area of the rectangle
The same thing let me also print out the perimeters
So to print out the perimeters so I'll say console.log
The perimeter of the rectangle will be rectangle perimeter
Now I must tell you that this kind of approach for implementing takes a little bit of effort to understand and internalize the asynchronous function ability
Takes some time for you to completely understand how it really works
Now to illustrate the fact that this function call will result in a call to the Node module but this part will be executed only after a two second delay because of the fact that we are using the set time mark
Now as we studied in asynchronous operation because we have moved off the processing to the back let me also introduce one more console.log here to make a point
So we'll say this statement is after the call to rect
The reason why I am illustrating this point is that when you issue this call this code will not be executed until after a two second delay
So in the meantime your function main function here will continue on and then execute the next line of code that you see here
So this is the continuation that you will see here
So with these changes let's save the changes and then look at how this application executes now
So saving the changes
Let's go to the terminal and execute this node application
Now going to the terminal add the prompt
Let me type npm start and you will immediately notice that the solve and this statement were printed out earlier
And then after this certain delay the area and the perimeter was printed out
So that is a two second delay that we introduced using the set time out
So you noticed that in the earlier version this was printed and immediately the area and the perimeter was printed right below that
But now notice that those values are printed a little bit later
So in between their function calls with the different parameters that are already gone in and then the callbacks are called back after two second delay for each one of them
And because of the fact that there is the closure that the JavaScript supports so the values that get passed in is preserved
And so when the callback function is called the appropriate value is printed
So that's why you see that the area and the perimeter are printed correctly and these two here these two statements here correspond to this particular call to direct with l is equal to two and b is equal to four
And then these two the next to two of course correspond to this particular one and the remaining ones as you see here
So what I wanted to illustrate is the fact that when you do asynchronous computation the asynchronous computation takes its own time to return the value while your main computation will proceed forward without waiting for the callback to be completed
So when you need to do a certain amount of work you passed in as a callback to that other module
And when that other module completes its work it's going to callback and then that code will be executed
So that is the point that I have illustrated using this example
Again as I said this takes a little bit of imagination and understanding for you to internalize the way this works but you will see that with Node and also Express and when we use MongoDB you will see this kind of pattern repeating very often in the way we write our code
So with this simple illustration of callbacks and error handling we complete this exercise
This is a good time for you to do a get comment with that message node callbacks and error handling.
Let me start out by giving you a quick 10 minute introduction to the Essentials of Networking
Given the fact that we have limited time I would concentrate on delivering you the essentials that you need for understanding each of the topics
Now what we cover in this particular module will require at least a rudimentary understanding of how computer networking works before we understand why we need to use HTTP why we communicate with a server what is the reason for the delay when you are talking to a server and so on
And also the various protocols that you need to be aware of before you can even communicate with a server
So keeping all this in mind a 10 minute quick introduction to the Essentials of Networking
We begin to realize that web applications are no longer stand alone
They always have a quote unquote Cloud backend supporting your web application
Now these days everything is on the Cloud
Pretty soon you will be on the Cloud too at least on cloud nine with a silver lining
But given that we need a server side support for our angular application to work correctly there would you host the server
And these days hosting the server is very easily done by using one of the cloud based infrastructure services things like Amazon Web Services or Heroku or Digital Ocean or many others that provide cloud based server support
So what exactly is available on the server side? You typically have a server frontend that is talking to your angular application so that is the server logic and behind the scenes the server logic is communicating with a persistent storage like a database where your data is stored and retrieved from
When you enter the networking world you'll be pretty soon bombarded with 304 little acronyms things that you thought you knew what they were from normal English or they have an entirely different meaning or purpose when you encounter them in that networking world
So let's examine a few of them
So in the networking world you will hear people talking over HTTP protocol
The protocol that is used for communicating between the client and the server
This is an application layer protocol that we will briefly talk about a little more in the rest of this lecture
The HTTP protocol for it to work needs a URL to be supplied to it the Uniform Resource Locator
So this is a string of characters separated by slashes with an HTTP colon or an HTTPS colon attached in front of it
And I'm sure if you have used the World Wide Web you are pretty familiar with what the URLs look like
Now in addition you would hear people talking about JSON not your friend Jason but JavaScript Object Notation
So the JavaScript Object Notation is one way of encoding data that is being shipped from the server side to the client side or vice versa
And also you will hear people talking about XML yet another way of encoding data while it is in transit shipment between the client and server side
Now also you will hear people talking about higher level protocols called SOAP not the kind that you take a shower with but SOAP as a protocol that allows communication between distribution entities within their network
And also you will hear people talking about REST not something that you get too much going through this particular course REST or Representational State Transfer
I will have a shorter lecture specifically devoted to REST a little bit later in this module
And in the HTTP world you would hear people talking about GET PUT POST and DELETE and you'd be wondering what do they all mean? Let's learn a little bit about these in this lecture and also the lecture on REST that you will see a little bit later
One important thing that you need to understand when you are communicating with a server is that the client server communication causes unexpected amount of delays or indeterminate amount of delay while the data is being either fetched or uploaded to the server from the client site
So which means that within your client site application you need to keep the user informed about the fact that something is going on behind the scenes and be able to handle the delays and possibly not being able to obtain the data from the server side
It is quite possible that when you try to connect to a server the connection of the server may fail the server may return incorrect data or may cause an error in communication
All these have to be handled on your client side appropriately so that your application will still keep functioning even in the presence of these problems
Jumping into the most popular application layer protocol used for communicating between the client and the server the Hypertext Transfer Protocol
But this is a client server communication protocol
Now that may or may not make much sense to you unless you have sufficient background in networking but this is a protocol that is used for encoding the messages that you exchanged between your client application which is an angular application in this case and a server side
So this HTTP protocol allow you to retrieve hypertext based documents from the server side increasingly the information being downloaded from the server side is encoded in one of the standard encoding formats like JSON or XML
And in order to be able to talk to a server you have the support from various HTTP actions or what we refer to as HTTP verbs the HEAD GET POST PUT DELETE TRACE OPTIONS and CONNECT
We will see in particular the GET PUT POST and DELETE verbs in more detail when we examine the REST API protocol a little bit later
How does the HTTP protocol work? In the HTTP protocol you are sending GET request from your client application to the server
And this is encoded in the form of an HTTP request message
The request message typically carries a URL in the request message indicating what is it that you want the server side to send you
And this is typically a GET message if you want data to be downloaded from the server side
You will also specify which particular server you are communicating with
When the server receives your request the server will retrieve the data from its data storage typically a database on the server side and then package this data in an appropriate format and send the data back to you on your client side
If you are obtaining standard HTML CSS and JavaScript code from the server side then your browser is able to render this
But with applications like Angular you are primarily connecting to the server and then retrieving data in the form of either JSON or XML most of the time
Except for the initial download of all the resources that are required for your Angular application to be executed within your browser
So as we saw earlier the HTTP application requires messages to be sent between the client and the server
A request message is typically sent from the client to the server and the request message consists of a request line plus a bunch of headers where you supply additional information to qualify the request
We will see the use of various headers and settings in the headers as we go through some of the exercises in this particular module
The request line and headers are separated from the body of the request message by one blank line
The body of the message may contain additional data especially if your client is sending data over to the server side
For example when you submit a form the information within the form is encoded into a JSON format and then sent over to the server side from the client side
So that will be done using either a POST or a PUT message
Looking at the little more details of the HTTP request message the typical request message in the request line will contain the method which is either GET PUT POST DELETE or some of the other verbs that you have seen earlier and then followed by the URL and the version of the HTTP protocol that you're using for communicating from the client to the server side
The header field usually contains a header field name colon and the value for that header field
And the body contents as I mentioned could be encoded in either JSON or XML format
Here is an example of a typical HTTP request message that may be sent to the server from the client
So in this particular request message we are asking the server to retain the index.html page from the server side to the client side so that it can be rendered in the browser on the client side
A request like this would typically have an empty body in the request message
Most of the information will be encoded in the request line plus the headers of the request message
When the client sends the request to the server
The server will process the request and then send back a reply to the client side
The reply message is organized into again three parts a status line where some information about how the request has been processed and what is being sent back to the client is stored the headers will contain additional details of what is contained in the response message and then followed by a blank line and then the actual body of the message
An example of what would be typically contained in an HTTP response message in this case this response message is coming back with a 200 which is a status code of the message
If you see a 200 in the request line as a status code it means that your request was successful and the server is able to return the data that you have requested from the server side
And then the header will contain additional directions to the client side including information about how the actual body of the message is encoded
Then the body may contain if you have requested the index.html page the body of the message will contain the HTML code for the index.html page as you see in this example here
One of the pieces of information in the status line that I refer to as the status code
If the server is able to process your request correctly it will send back a reply with a status code of 200 meaning everything is okay on the server side and the server side is returning the data correctly
If the server is unable to process the request for whatever reason then that information will be encoded in the status code in the status line of the reply message
The various status codes typically that you will encounter when you receive a reply from the server side include a 201 which means that when you try to create an object on the server side it has been successfully created or a 301 which means that whatever you are requesting has moved permanently to a new location and the URL of the new location of that resource will be returned to your client side
400s and 500s typically indicate that there is some problem on the server side
404 is something that you often encounter when you request for something that doesn't exist on the server side
Similarly 500 means that the server is just giving up it is unable to process your request and then sends back an internal server error
These are two common error codes that you will encounter
The remaining ones have specific meaning as listed in this table here
There are more than the status codes that I gave you in this table but these are some of the most common status codes that you will encounter in a reply message coming from the server side
Another point that I mentioned is the fact that the server may encode the data in a specific format like XML or Extended Markup Language or JSON the JavaScript Object Notation format
Now typically in this particular course we will be dealing with data that is encoded mainly in JSON
Most client side applications including mobile applications these days typically communicate with the server and the data exchange format is JSON by default in most cases
That is the reason I will spend a few minutes explaining to you about JSON
The JavaScript Object Notation or JSON is a lightweight data interchange format
The reason the JSON data format is specifically of interest to us in this course is because the JavaScript Object Notation as the name implies very easily maps into a JavaScript object that you use with any JavaScript code
So converting a JavaScript object into JSON notation and vice versa is very straightforward
The JSON notation is what we call as a self describing and very easy to understand notation
In the JavaScript Object Notation format the data is structured in a very clean specified manner
This is structured as a collection of name value pairs and this is structured as an ordered list of values
You can see an example of this on the right hand side here
We have actually used this JSON data within our angular application already earlier
So now you see why the data is structured that way
And you also realize that it is very easy to be able to deal with this data within your JavaScript or your TypeScript code in your Angular application
With this I complete a quick overview of networking essentials.
In the previous lecture we learned about the essentials of networking including details of the HTTP protocol
Now we'll look at how Node can be used to construct an HTTP server
This is where the core HTTP module that is built into Node comes to our aid
In addition we will look at a couple of other core Node modules that are useful for building an HTTP server from using Node
So how do we make use of the Node HTTP module? As I mentioned the HTTP module is one of the core modules that are built into the Node
So this is a core networking module that supports a high performance foundation for HTTP stack
So using the module within our Node application requires us to import the module into our application
So this is what we do by saying const HTTP = require and the name of the module HTTP there
Now once the module is imported then this HTTP module supports a createServer function which takes as a parameter a function that acts as a callback function for the createServer module and this function has two parameters : request and response
The request is the request message that comes in from the client side and we can parse the request message and then extract a lot of information from the request message and use it to make decisions on how we construct the response message corresponding to that
The response message is constructed using the second parameter here the res on which we can construct the various header values for our HTTP response message and also the body of the HTTP response message
Now to start the server once you create the server then you would say server.listen and then supply the port number and the host name for the server and that will start up our server
We'll look at some details in the examples exercise that follows this lecture
As I mentioned the incoming request message information is available through the req parameter that the function takes in the createServer method
So the req or request if you want to give it full name you can call it as a request but in general we have found that in examples we used req to represent the request message
It supports on the Javascript object properties like the header the body and also various information that can be extracted the URL and the method that has been requested by that client site
And in response you construct the response using the response Javascript object which supports that setHeader function the statusCode function which can be set to the status code of the response message
And then you would write the message saying res.write and you would end the message by saying res.end and that takes the final part of the body for the message
The body may be either standard text or HTML or any other information that you want to enclose inside the body of that reply message
But once the res.end is called the reply is sent back to the client from the HTTP server
Two other core modules that are useful for us when we're constructing the Node HTTP server is the Node path module
The path module enables us to specify the path to a file and then examine whether the file exists or examine more details about a file
For example the extension of the file name and so on
So the path module can be used within our application by requiring the path module as shown here
And then this supports methods like for example path.resolve which will convert a relative path into an absolute path that the entire path to the file
You can also check the extension name for the file by calling the path.extname function and supply the file path that will examine the extension of the filename
Similarly the file system module again a core module in Node will enable us to read and write files that exist in the local file system on the computer
So the file system modules can be used within our Node application by requiring it as shown here
And then these file system modules supports many methods including a method for checking whether the file exists in the local file system or not
So the fs.exists will take the filePath as the first parameter and the second parameter is a callback function which will come back with a parameter which we can name it as exists
This parameter exists will be true if the file exists and will be false if the file does not exist within the local file system
Similarly you can read from the file by creating a read stream given the file path
So you can say fs.createReadStream and the filePath and this can be piped in to the response message
So the file will be read in from the file given by the filePath and then the contents will be put into the body of the response message by calling a chained function as shown here
So these are some examples of some core Node modules that will be very useful when we are constructing a HTTP server using Node
Now that we understand some details about the HTTP server and how it can be constructed let's go to the exercise where we will construct a simple Node HTTP server which first will serve up some basic information and then after that we'll serve up files that exist in a public folder in our project.
In the previous lessons we have learned about Node
We have also seen how Node can be used to set up a Web server
Now the Node designers intentionally kept node small with a small number of code modules so that they can leave it up to third party developers to come up with innovative solutions to problems
So once Node was released a number of third party developers started designing and releasing interesting third party modules that can run on top of the Node platform
Now you have seen a number of Node modules that could be used for front end development in the previous courses
Now in this course we are looking at server side development and on the server side one of the most popular third party Node modules or frameworks for building HTTP servers is Express
Let's look at some details of Express in this lecture and then we will make use of Express to build a server that serves up the REST API throughout the rest of this course
First what is Express? Express is a fast unopinionated minimalist framework that runs on top of Node.js and supports Web development
This is the definition that I borrowed from expressjs.com the site where Express related documentation is available for us
Now Express allows you to develop a Web application server side application that will serve up content for consumption by our front end
Express provides a robust set of features which we will explore in more detail through the rest of the lessons in this course
Express itself as I said is a minimalist framework and Express also provides a way of extending and adding functionality to Express through third party middleware
This extends the functionality of Express and adds in more features as required
So you can build your Web server using just as many third party middleware as required for meeting the needs of your Web server that you're designing
We'll look at some examples of third party middleware in this lesson and we will also explore more of these as we go through the rest of the lessons in this course
To use Express in your project of course the first step is to install Express and since Express is a Node module we install it by saying npm install express   save and this would install Express into your local project
We will see the use of this in the exercise that follows this lecture
Let's briefly talk about the Express middleware
So what exactly is the purpose of middleware? The middleware that Express supports provide a lot of plug in functionality that would be used to enhance your Express application plug in functionality like for example we will look at a middleware called Morgan which allows you to print out log information to the screen about the requests that come into your server
Similarly we'll look at another middleware called BodyParser which allows you to parse the body of the incoming HTTP request message and extract information from it for use within your Express application
We'll see the use of these in the exercise that follows
As I mentioned Morgan does logging of information to the console on the server side information about the incoming requests
Similarly they can serve up static Web resources from our server using the Express static so this will serve up information from a folder within our Express project and in declaring the project you can say I'm double underscore filename and double underscore directory name or dirname which gives you the full path for the file or the directory for the current module and you will see me using that in the exercise
Now that we have understood a little bit about Express and the middleware that Express uses let's look at a Node module because this is the first time we're encountering a third party Node modules we'll look at some details about the third party Node modules so if we'll examine the package.json file to see what is contained in the package.json file we'll also look at semantic versioning
So when you specify the version of the package that you use you always specify the version by specifying the Major Version.Minor Version.the patch
So when you install a package it is always identified by these three numbers major version which might introduce breaking changes so which means that if you are installing a newer version of package it may not be completely backward compatible with previous versions
It may introduce breaking changes whereby you may need to go back and fix the code that you might have written in the earlier version of your project
The minor version introduces some minor changes to your package and may not be breaking changes
A patch would be a bug fix that is often issued then a small bug is discovered
So patches usually do not lead to any breaking changes and so you can easily use a higher version or a higher patch version of a particular package that you're using within your Node application
When you're installing a package you can specify the exact version of the package to install by saying npm install for example if you want to install the 4.0.0 version of Express you can say express@4.0.0
So you are explicitly specifying which version of the package to install
If you're okay with a higher level patch version you would say npm install express@"~4.0.0 If a minor version higher version of a package is acceptable then you would say @ and the name of the package
Now this kind of information is also saved in the package.json file we'll quickly pay a visit to the package of json file where you will notice some of this information being saved
Now when you do the exercise that follows this lecture you will see this in the package.json file
This will be the result of completing the exercise that follows this lecture
In the exercise we will construct a simple Web server using Express
Now let me take you through a quick tour of package.json to illustrate some information in package.json
So in package.json file you'll notice this information here this property for our json that is stored here called Dependencies
The dependencies is where you will specify which additional third party modules on which this particular Node project is dependent upon so as you can see here we are saying that this project is dependent upon Express and Morgan and note in particular how this information is specified here
So this is ^4.16.3 meaning that this will work with any version that is 4.16.3 or higher
You can use a higher level minor version and this project will still be okay with it and similarly for Morgan we have specified the information here
So this additional information is added into the package.json file whenever you do npm install and say   save flag for the npm install
Now also you will notice that I have created a.gitignore file here and inside the.gitignore file I have specified that git should ignore the Node modules folder
So what exactly is contained in the Node modules folder? If you install third party modules into your Node application all these third party modules will be saved in the Node modules folder here so within your project you will see that the Node modules folder has been created here
And taking a look at the node modules folder you will see a whole bunch of packages that have been installed
Now all of these have been installed because you install Express and Express in turn depends upon some other packages that are required so all those also get installed here by default
In particular let me also draw your attention to the Express package here so if you go into the Express package you will see additional information being stored in the Express package so index perspective also since Express itself is a Node module you will see a package.json file inside Express also which contains additional information which of course is very detailed there difficult for us to understand but note in particular that Express itself is dependent upon many other Node modules here
And that's the reason why all these other Node modules also have been installed into the Node modules folder
So when you install Express this will immediately also trigger all its dependencies also to be installed because Express will require these other Node modules for it to do its work
Also within Express also you'll see the index.js file
So this is the starting point for our Express Node module itself and note in particular that the index.js file simply says module.exports require lib express
So the actual code for the Express module itself is inside this lib project lib folder here and you can see the detail
So if you are curious to see the details of Express itself you can go and look in there but again this may be a bit too much for you at this moment
For the moment just accept the fact that Express will do its work as expected
But I thought that it will be a interesting experience to visit the Node module's folder to look at a structure of one particular third party Node module in a bit more detail
Also you will notice that there is another file here called package lock.json that is installed
Now this is being installed by the newer versions of npm
The package lock.json file is automatically generated by npm which stores information about the exact tree that was generated when you install other Node modules and this is very useful when you need to do installation of the Node modules at another location
So for example if you download a Git repository and try to recreate this project on another computer you would simply type npm install on the prompt and that'll prompt your Node application to automatically install everything that is specified in the dependencies here for you
While creating that the package lock.json stores additional information that is used by npm to do the correct installation of all the npm modules that are required
Now for the moment you don't need to worry about the details of what is there inside the package lock.json file
With this we complete this lesson where we have examined some details about Express.
In the exercise in the previous lesson we built a simple HTTP server that could serve up static content this was built completely using Node.js
Now that we have learned about Express the minimalist framework that supports development of server on top of Node.js let's now examine how we can use Express to build the same server in this exercise
To get started go to the Node.js folder that we have been using for storing all the code for this course and thencreate a new folder there named node express and then move into this folder
Now we will create a public folder here within the node express folder
Then we will go to that node HTTP public folder and then copy these two files the index.HTML and aboutus.html to the node express public folder
We're going to serve up these two files using the Express server that we're going to build in this exercise
Now going to the terminals
Move into the node express folder in the terminal and then at the prompt type npm init to initialize a node application
Then for the package name let's just use node express and for the description we'll say Node Express Examples and entry point is index.js and all the rest of that same like before and let's create the package.json file
Now let me open the project using the editor Visual Studio Code in my case and then in the package.json file let's go in and add in the new script called start which is node index and save the changes
Now that we have initialized the node module let's go ahead and install the Express framework within the project to make use of it to build our express server
So at the prompt type npm install express
So this is how you would install a third party node module if you are taking this course for the first time and have not taken the previous courses then this is something that is important to note
This is how you will install a node module by adding the minus minus save we are also saving the information that this third party node module is a dependency for our project and this information will be saved in the package.json file
If you have taken the previous courses of the specialization then you already know about this information
So let's go ahead and install the Express module
As you can notice we are using Express version 4.16.3 in this course
So let's now go back to our code
Taking a look at the package.json file you see that within the package.json file by installing Express we already see another property that is included into the package.json file called dependencies
This dependencies track all the packages on which this current project is going to be dependent upon
Here you see Express being installed there and the corresponding version of Express being installed here so this declares that this particular project is dependent upon Express version at least 4.16.3
In addition you also see this folder called node modules created here
So this is where all the third party node modules that are installed by your application are going to be stored
Now when we do a Git commit we don't want to commit this node modules folder
So to ignore that lets create a file named.gitignore and within the.gitignore file let's type in node_ modules
So this is letting Git know that we do not wish to commit the node modules folder to the Git repository
So with this let's save the changes
So now when you create a Git repository the node modules folder will be ignored
It is not required because you can always recreate the node modules folder anytime you clone this project from your Git repository by simply typing npm install
This will look at the package.json file and look at all the dependencies and the development dependencies that are in the package.json file and are automatically installed all those packages for you
Now that we have completed this let's create our first Express project so to do that we'll create a file named index.js and in the index.js we'll declare a const express require express
Now you'll note that express is a third party node module and it has been installed in our node modules folder in the correct directory
So when we declare this here saying that this Express module is required then it will be automatically included from the node modules folder into our application
Now also install HTTP the core module here
Now that we have installed this let's create the course name as local host and port number as 3000
So you see that we are using exactly the same way of doing this exercise as we did for the HTTP exercise earlier
Now at this point we will declare this const called app as express
So this way we are saying that our application is going to use the Express node module
So once we do that then Express provides a bunch of methods that we can use to construct our web server
So after this we'll say app.use() and inside here we will declare a function that will be called to set up our server
So this function takes three parameters req which is the request; res which is the response and next
Now as we saw Express uses additional middleware
So the next is used when you need to invoke additional middleware to take care of work on your behalf
We will see the use of next in some of the later exercises but the function here will take three parameters req res and next
Next is an optional parameter that can be not included if you are not going to use it within your code
So inside here we'll say console log and then we'll log that headers and we'll respond with the status code set to 200
Set header content type as text HTML
So you notice that much of this code looks very similar to the way we set up our node application
So we'll say res.end and here HTML body h1
We'll just say this is an Express server and close off the tanks there and that's it
From your understanding of the node HTTP you already understand what these three are doing and the same thing is also done in the Express server
Now that we have set up the server using the App we will set up the server and then this is where we will use the HTTP createServer and thus createServer is now going to take app as it's function parameter there and thereafter we'll simply say server.listen port hostname and the arrow function here within which I'm going to print out console log back coat server running at HTTP://hostname:port that's it
So you'll see that this part is very much similar to what you have done for the HTTP exercise except that the createServer now takes this app which we have declared earlier Express
So Express is adding in additional functionality which will be used by the HTTP server that we create using note
Once we are done with this let's save the changes and then we will go ahead and start the server and have a look at what the server will serve up
Going into the terminal add the terminal type NPM start and you will see that your server is up and running
Now when we access this from either the browser or from postman you will see what it serves up
So here I have Postman up and money
Let me send the GET request to localhost 3000 just like before and you will see that this is serving up the HTML code that we include in there and so this is an Express server
Clicking on the preview this will show you what it will look like in a browser and this shows the raw version of the code that has been sent back from the server side and you can see that the status code is 200 okay? And the other header information vector has been sent from the server site
Notice in particular it says x powered by Express in the header
With this we complete the first part of this exercise where we have seen how we can make use of Express to set up a simple web server
Let me now stop the server and then initialize the Git repository so at the prompt I will type "git init" and then "git status" and you'll see that files that have been untracked so I will say "get and dropped" and these files are now added into the Git repository and so when you say git status you see the files that have been added
Note in particular that the node modules folder has not been added to the Git repository because in the.gitignore file we explicitly stated that the node modules folder should not be included in the Git repository
So now let's check in our commit exchange by saying git commit minus m Express example and we have committed this to our Git repository
In the second part of this exercise we will look at the use of Express middleware called Morgan
Morgan is used to log information to the screen so it'll log information about incoming requests to the screen so that we can see some information being printed in our console here
Also we will see how we can set up our Express server to serve up static HTML files
To get started at the prompt type npm install Morgan minus minus save
Now Morgan is going to be a dependency that we're going to be using in our Application
So that's why it's minus minus save and this would get Install and you can see that I'm using Morgan version 1.9.0 in this course
Now that we have installed Morgan let's see how we can make use of it within our Application
So going to our Application the way to make use of Morgan is to declare here const Morgan require Morgan and then we'll say "App use Morgan with the development"
So this is the development version
So it will print out additional information to the screen as required
Now going into our application
Within our application I'm not going to log the entire headers
Instead let me remove this because Morgan will log sufficient information for us to look at and I'm going to set up my server to serve up the HTML files from the public folder
So to do this I'm going to declare up use and express static
This tells Express to serve up the static files from double underscore dirname
So this says the root of this project and they will find those files in double_dirname plus/ public
So recall that we created the public folder in the node Express folder
So this is informing Express that you will look at this particular folder in the root folder of this project and inside the public folder
So this will be the folder from which static HTML files will be served up by my Express server
After making these changes let's save the changes and then restart our server and then see how it works
Going to that prompt let's type npm start to start our server and once the server is up and running let's examine what it will serve up when we send various requests to this server
Using Postman let's first send a get request to local host:3000 and you'll notice that it is serving up the index.html file
We have set up our server to serve up static files from the public folder and if we just say localhost:3000 by default it'll serve up the index.html file
So this is how your typical Web server works
So that's what we have ended up setting up our express server to do
Now let's type in localhost:3000 about.html and send the request and says this is about our strategy HTML and also the about us HTML file has been saved up here
So in the preview you can see the resulting file that has been served up from our server site
Let's try to access a non existent file and you'll see that when you try to access a non existent file then it will default to the second setup that we have done in our code which says this is an Express server
We have not specified to our Express server how to handle situations where it encounters a file that doesn't exist
So that is why it is using the default that have set up right below the Express static which is to serve up the default value and of course this is not the most ideal behavior but that's what we have in the Express server at this moment
Later on we will modify the Express server to handle errors in more detail in later exercises
This is also a good time for you to do a Git commit of the changes
So let's check Git status after stopping the server and we'll add the modified files and then do Git commit minus m Express serve static files
That's it
With this we complete this exercise
In this exercise we have seen how we can set up a simple web server to serve up content on our behalf.
Let me give you a brief rest
Got you there
What I meant to say was let me give you a brief overview of Representational State Transfer
What exactly is REST? How do we make use of it in our React application and how do we make use of this to communicate with the server? How does a server support REST API and how do we access the REST API from our React application? Let's talk about that a little bit more in this lesson
I'm sure you've heard the term web services being mentioned in the IT world very often
What exactly are web services? Web Services are a way of designing systems to support interoperability among systems that are connected over a network like the internet as we see today
This is what we refer to as a service oriented architecture
Now what this means is that you provide a standardized way for two machines that are connected to the internet to be able to communicate with each other at the application layer level for web based applications using open standards
Now I have used a lot of jargon there
Let's try to break them down and understand a little bit about each of that in this lecture
Two common approaches that are used for supporting web services are SOAP
The Simple Object Access Protocol based web services which uses the web services description language for specifying how the two endpoints communicate with each other
Typically SOAP is based on using XML as the format for the messages being exchanged between the two endpoints
Representational State Transfer or REST also uses web standards but the exchange of data between the two endpoints could be either XML or increasingly using JSON as the format
The REST way of interoperability is simpler compared to SOAP and hence REST has found a lot wider deployment in the web services world
Typically client server communication is facilitated using REST where the server supports a REST API and the client can then invoke the REST API endpoints in order to obtain information or to upload information to the server
Again I have mentioned the word invoke the REST API endpoints so these are a few terms that I have used
Let's clarify some of these in the next few slides
Representational State Transfer is a style of software architecture that is specially designed for distributed hypermedia over the World Wide Web
Now this was first introduced by Roy Fielding in his PhD thesis
Now this is one of those PhD theses that actually produced something useful for the world
So this has found again a lot of traction in the web services world
This is a collection of network principles that outline how resources can be made available on servers and these resources can be accessed from clients by identifying the resources using rest API endpoints
Within Representational State Transfer there are four basic design principles
First and foremost REST is built upon HTTP protocol so it uses all the HTTP methods that we have already seen in the previous lesson
Second REST is designed to be stateless meaning that the server doesn't store any information about the state after the communication is completed
So when a server receives the request the server replies and then after that it doesn't remember anything more about the conversation between the client and the server
Third the REST way of providing resources is to expose a directory structure like URLs (Uniform Resource Locators   URLs)
Fourth the format for data exchange is typically JSON or XML or both can be supported using REST
One of the motivations for Roy suggesting REST as a way for supporting web services is that it captures all the things that are good about the World Wide Web and that made the World Wide Web successful
The use of Uniform Resource Indicators or Uniform Resource Locators (URLs) which allow you to address resources by specifying them as a URL
The second one being a protocol that lives on top of HTTP protocol
HTTP has already found wide deployment in the internet
Third the request response cycle that HTTP is well known for
So you send a request the server receives your request processes the request send the response to the request and the client receives the response acts upon that and may generate further requests
So this approach of the request response cycle is very well established with HTTP and the World Wide Web
Now the HTTP protocol as we have seen earlier we will use all the various verbs that HTTP provides
specifically the GET PUT POST and DELETE for being able to specify operations to be done on resources that are stored on the server side
So for example if you do an HTTP GET request you are asking for the server to return the resource
If you do a POST request you're asking for the server to create a new resource
If you do a PUT request you are asking for the server to update an existing resource
And if you issue a DELETE request you are asking for the server to delete the resource that is identified by the particular URL
Also it tries to preserve Idempotence
Some operations when they are performed even repeatedly will not cause any change of state
Some other operations if you do them successively they may cause a change of state
So you need to be careful about which operations can be repeated without any damaging consequences and which have to be very carefully done
In the REST world you often hear people talking about nouns verbs and representations
Now we'll clarify each one of these in a little more detail in the next few slides
Nouns specifically refer to resources and these resources are usually identified by their URLs and these are unconstrained
Verbs are constraint and these specify the actions to be done on the resources and representations as we see
When the information needs to be conveyed from the server to the client or from the client to the server how you encode the information
Typically either using JSON or using XML
Resource is the key abstraction that REST works around
So the information is abstracted in the form of a resource and the resource is identified by specifying it by using a URL
So any information that can be encapsulated and be made available can be identified as a resource
A piece of information like the current weather in Hong Kong could be a resource an image could be a resource a stock price information could be a resource and so on
So whatever you define as a piece of information that a client may be interested in can be identified as a resource
You can even deal with resources as collection of resources that the server may send up to the client
An example of how you name resources is illustrated here
So we use URIs to identify the source
A quick reading of these specification or the URIs here will easily enable you to understand what we are referring to by using these URIs
So for example something which ends with dishes/ you automatically assume that this is referring to a collection of dishes
But dishes/123 for example might mean dish number 123 in this case and so on
So it is very easy to save and you can specify a collection of resources and be able to identify them as a collection and then download them as a collection or you can identify an individual resource and say that you want that particular resource
Now these resources can be organized into a hierarchy of the specification of this URI
So as you traverse the path you go from the more general to the more specific of the resource
This directory structure enables you to identify the resources that you use or provide from your server side very easily
The second part of the REST API are the verbs
In particular we are interested in the four verbs of HTTP the GET PUT POST and DELETE
In this case these verbs will be mapped into actions that we want to be performed on the resource on the server side
A GET would mean you want to perform a read operation on the resource
So which means that a client sending a GET request is indicating to the server that it wants to obtain a representation of that resource from the server side to the client side
A POST means that you want to create a new resource and then you will specify the details of the resource in the representation that is used for specifying the resource and then send that information over to the server side so that the server will create that resource on your behalf
A PUT would be modification of resources and a DELETE as you would expect is deletion of the resources
So as you can see the four verbs; GET POST PUT and DELETE are mapped into the four CRUD operations that you can carry out on a database that stores these resources on the server side the READ CREATE UPDATE and DELETE operations
Elaborating further the HTTP GET is a way of specifying that you want the information or the representation of the resource to be returned to the client from the server side
So when you issue a GET request to a REST API endpoint you are asking for either a collection of resources represented by URI or a specific resource which is identified by the ID of that particular resource specified within the URL
So as you see in this example if you say dishes/452 you are meaning to say that dish number 452 with the ID 452 should be returned to the client side
Similarly the POST operation as we saw is used to create the resource
So when you create the resource the content of describing the resource would be in the form of a JSON representation or an XML representation and that will be included in the body of the request message that is sent to the server side
So a POST operation expects a representation of the resource in either JSON or XML format in the body of the request message
When the server receives that request message the server creates that resource on the server side and then returns either a conformation or a error to indicate that the resource creation failed
Similarly a PUT operation is used to update a resource
When you do a PUT operation on a resource on the server side you may send back the modification either by specifying only the partial modification that you want to effect on the particular resource in the body of the reply message or you may send the complete representation of the resource in the body of the message
Depending on the arrangement between the client and the server the server expects the information to be passed on in the body of the request message
A DELETE operation as you would expect deletes the existing resource
Now in this particular case of course a DELETE operation would be idempotent because if you try to delete a resource and the resource exists it will be deleted
If you are trying to delete a non existing resource it won't cause any further modification to the server side except that the server will reply with an error saying that the resource doesn't exist
But nevertheless DELETE is an example of an idempotent operation in this case
Similarly the GET operation is also an idempotent operation because it is not making any modifications to the resource on the server side
POST and PUT of course are going to modify the resource on the server side either create a new resource or modify an existing resource on the server side
Of course the representations as I have been emphasizing the two common formats for representing is either JSON or XML
The last part that we need to emphasize is that server side should be completely stateless which means that the server side does not track the client state because if the server needs to track the clients state it will not be scalable
So for a scalable implementation of the server side you normally use a stateless server on the server side
So every request that the client sends to the server will be treated as an independent request and will not reflect upon previous requests that have already been handled by the server from that particular client
So it's the responsibility of the client to track its own state either in the form of using cookies or using a client side database whatever means that is suitable
Now this approach where the client tracks its own state is a lot more scalable because each individual client will be responsible for tracking its own state
This is where the client side MVC setup helps us in this regard
Finally we are not yet done with REST
We will see more of REST in the exercises that follow in this particular lesson and then also we will see more details about REST usage in the rest of this course.
In the previous lecture we learned about REST API
You have seen how the REST API endpoints support a way for a client application to be able to either retrieve data from the server or upload data to the server using the various HTTP operations
In this lecture and exercise that follows this lecture we'll look specifically about what kind of support Express supports for designing and implementing a REST API based server
In particular we'll also look at the Express router and how it enables us to subdivide our application and then organize it into multiple mini Express like applications which combine together to form the Express application specifically when we are dealing with various REST API and parts
So to summarize in the previous lecture we examined REST in detail
We also looked at how each endpoint is identified by a URI and how we can specify the various operations to be done on each endpoint using the appropriate HTTP verb the GET PUT POST or DELETE
Now in this lecture we'll look at how Express supports the development of a REST API server
We'll look at Express's support for various matters like app.all app.get put post and delete and how these methods can be used to construct a REST API server
Within Express the various application groups can be defined using the app
and the various methods
So the app.all specifies an operation that needs to be done on all the various verbs on in and part
So for example in this example we see that the endpoint is defined by /dishes and so the app.all whatever is specified in the function that is given for app.all will be applied to all the incoming requests
The app.get specifies what needs to be done for GET requests and correspondingly for the POST PUT and DELETE requests which are sent to the /dishes endpoint as shown in this example
Express also supports defining the endpoints with parameters
So for example you can specify a specific dish ID if you wish to and then let the operation be performed for that specific endpoint referring to that specific dish with a given dish ID
So in this case the dish ID itself is specified as a parameter and the pattern used for that is as you see in this example /dishes/: and then you would specify the parameter here
To make it easy for us to understand I named the parameter as dishId in there
You can use any parameter name that you choose to but again using a meaningful name for a parameter makes it more easier to understand the code
So in this example the :dishId means that if we issue a request to an endpoint say for example /dishes/23 then the dishId parameter enables us to extract this number 23 so that we can operate on dish number 23 within the function that is specified inside this method here
So in there the parameter the dishId parameter itself can be obtained by using the request object on which the params property you supported and the params property supports all the incoming request parameters and dishId in particular is one of those request parameters which can be accessed as shown in the code here
When you send a PUT or a POST request from the client to the server you're often enclosing the data in the body of the message that is sent to the server
Now which means that we need a method of extracting information from the body of the message
So this is where the body parser middleware for Express is very useful
So the body parser enables us to parse the information from the body of the message
To use the body parser as we would expect we would install the body parser node module and then require it within our Express application and then specify app.use(bodyParser)
And if the body contains data in the JSON format you can say bodyParser.json so which means that this will parse only data that is in JSON format that is enclosed in the body of that request message
In particular in the exercise we will be parsing incoming data which is sent in the form of a JSON string
The body parser as you would expect parses the body of the message and populates the req.body property
So on the request the body property will contain whatever is parsed in from the body of the request message by body parser
If you are implementing an Express application which supports multiple REST API endpoints then it makes sense to subdivide the code into multiple modules and then make use of them to construct the overall Express application
So this where the Express router comes to our aid
An Express router defines many Express application and within that many Express application you can for example deal with one particular REST API endpoint in more detail or one particular pattern of REST API endpoint in more detail
So for example we can define a dishRouter as express.Router and then the dishRouter can then handle the endpoints
So when you express something as express.Router it supports the route endpoint
One of the reasons for using Express router as you would realize is that if we use the standard app GET PUT POST and DELETE methods for each one of these methods you need to explicitly specify the REST API endpoints
One advantage of using Express router is that if you say the router.Route and then specify the endpoint that endpoint will be applied to all the methods and all the various GET PUT POST and DELETE verb related methods can all be chained together into the route in defining the code for our application
We'll look at more details of this in the exercise that follows this lecture
With this quick understanding of how Express supports REST API endpoint let's move on to the exercise where we will construct their support for the /dishes REST API endpoint
As part of the first assignment you will be further extending this Express application to support additional REST API endpoints including /promotions and /leaders
If you have taken the previous courses in the specialization you will immediately begin to see why we are supporting all these different REST API endpoints on other server side.
 Now that we have understood REST API and
express support for REST API
let's move on to the next exercise
Where we will look at how we
will develop the REST API using the support given by express
And also the use of express router enabling us to organize our code
in a way that is more suitable when you need to support a large
number of REST API endpoints
To get started
continuing with the node express folder we have been working on
the express based web server
At the prompt let's install body parser so to do that
type npm install body parser   save
And we are using the 1.18.3 version of body parser in this course here
Now once we have installed body parser
then go into our code
In the index.js5 let me require bodyParser so we'll say const bodyParser require body parser
And then whenever you
need to use a middleware you'll say app.use(bodyParser.json)
So this allows us to parse
the body of the request message which is formatted in JSON format
Once we have completed that
then let's start building up The REST API support for
the /dishes endpoint
Using the app.all app.get put post and delete methods are supported by express
So to do that let me start out by saying app.all and the first parameters that app.all takes is the endpoint
So in this case
I am specifying the endpoint of /dishes
And then the second parameter
is the callback function req res next the three parameters here
And inside this callback function we're
going to handle the incoming request
So we will say when a request comes in
for all the requests
So when we say app.all
no matter which method is invoked get put post or delete for
the /dishes REST API endpoint this code will be executed
first by default here
So we'll say res StatusCode is 200 and then res.setHeader and let's say Content Type text
We'll send plain text now
instead of HTML text
This should be enough for
REST API endpoints
Later on we will send the data
in the form of JSON once we are able to retrieve
the data from the database
So that will come in one
of the later exercises
For the moment we'll simply send
plaintext replies back to the client
Now after these two
the middleware here is not completed yet
So we will call the next function here so
the next as you see refers to this next
So when you call next what it means
is that it'll continue on to look for additional specifications down below here which will match this dishes endpoint
So this would be done for
all the requests get put post and delete on the dishes and
it'll continue on to the next one
So here suppose we get a get request on dishes which means that now if we get a get request on dishes first this will be executed and then the req and res will be passed on to this second call here
So in this case
I will no longer need the next because I'm not going
to call further down
I'll complete the handling right
within this method here itself
So if we modify the req or
res inside this code then when you call the next
that modified object will be passed in as
the parameter to this
So if you have issued a get request
on dishes so this is what will be executed right after this so
this next will cause it to pass on
And then here you notice that
we modified the res object here
And the modification will carry in as
the input parameter to this function here
So inside this get function
we can say for example at the moment I'm simply going to send back
a simple message we'll say will send all the dishes to you
Later on when we retrieve the dishes
information from the database after we learn about MongoDB
then this function will be returning that JSON data back to the client
since it's in a get request here
Now in the previous course
we had used the JSON server and the JSON server was already
providing all of these for us
Now you are seeing how you would construct a real server that will
process the incoming request
And then generate
an appropriate response and send it back to you in response to
the request received from the client side
And this is where the user express
as we see here is useful
So we have handled get let's handle post also on dishes here
And again
the parameters would be (req res next) and that function that
is invoked will be here
Now when the get request is received
because here you're calling rest.end
So that end is the handling of the get
request and doesn't trigger the reply to be sent back or response to be
sent back to the client at this point
Now if you get a post request on dishes
again this whole code will be executed
And then because of this next that
will drop into this function call here
And then the code here will be executed
so when you receive a post The post request coming in from
the server will carry some information in the body of the message
in the form of JSON data
They'll see what the form
of the JSON data is when we look later on when we test
end point using post net
I'll show you what the body of
the post request message will contain
But at this point
what I'm going to do is I will extract the information
from the body
And so here when we use the body parser
what happens is that for the incoming request the body of
the incoming request will be parsed and then added into the req
object as req.body
So the req.body will give you access
to whatever is inside that body of the message
So when I send the request I will add information to the request body in the form of a JSON string which contains a name and a description
So I'm going to extract these
two piece of information and then print them out and then send them
back to the client in the reply message
So I can say req.body.and then name
And so the expectation is that when
the client sends the post message the post message body will
contain a JSON string which will also contains the name
property in the JSON string
So req.body.name plus and this is where I will include with details: + req.body.description
So whatever the JSON string
contains in the req.body but JSON string will be parsed
into a JavaScript object and added in to the request
object as a property body
The JavaScript object points to whatever came in as the JSON string in
the body of the request message
So that is why I am able to parse the name
property the description property you can have the price property
the image property and all of that
So if you've taken the previous course
you've seen the structure of a dish object in the form of a JSON string or
the JavaScript object there
So the name and
description sounds familiar to you
So that exactly what I am using here
Right now I'm only extracting the name and
the description from the body and then sending it back to
the client in this body
So I'm just constructing this reply
message here using the information from the body of the request message
and then sending it back to the client
So that way I can confirm that the server
is receiving whatever I am sending in the body of the message
So this is the post request
Now for put let me just copy this
and then paste it here
And then for put on that dishes endpoint because it put on the dishes
endpoint doesn't make sense
A post means that you're posting
a new dish to the servers
A put on the dishes end
point doesn't make sense so here what I'm going to do is I'm going to reply back with the message PUT operation not supported on /dishes
In addition I will also
Include a status code of 403
403 means their operation not supported
So if you look back at
the HTTP response codes table you will see the corresponding
code 403 what it represents there
So that is what I am using for post
For delete I'm going to copy this one and for delete I'm going to Simply parse this and then we'll say
Deleting all the dishes
So when you send a delete request
on that /dishes endpoint
It is interpreted to mean that the client wants to delete all the dishes
information on the server side
Now this is a dangerous operation so you make sure that you don't
allow partner users to do
So later on when we study authentication we'll see how we can res check this
operation to only privileged users
But again as you see this is a dangerous
operation so keep in mind about that
So now you see that in the dishes
endpoint we have get put post and delete support
Let's also support that on
the dishes/:dishId endpoint
So I'm going to copy the get put
post and delete methods from here and then calls all of them
also to be supported on dishes/:dishId
So this is for the get
and we copy that and post put and delete
How do we handle each of these? So for get
if I get a request on dishes/dishId what I would like to do is to
extract this parameter and then send it back in the request
in the reply message
So we'll say we'll send Details of the dish
Now which dish? This information is in the parameter
So this parameter value can retrieve from req.params.dishId
So this dishId as you see the name that
you use here should match this value here
So if you just simply see ID here this should also be corresponding
the given sId here
So the name itself doesn't mean anything
except that this parameter name and this should match each other so that you
can retrieve the information correctly
So we'll say
send the dish parameters dishId and then we'll say to you
So that way we know that the server
is getting the dish parameter.
So if I say /dishes/23
there several replies will send the details of
the dish 23 to you and so on
So we'll see how it works when
we use post to test this Server
Now for post
For post
this method is not going to be supported so I'm just going to copy this part
it doesn't make sense to do
a post on a specific dish ID because you're not trying
to add a new dish
But you want to modify and modification
is done by using the put operation
So we'll say
POST operation not supported on /dishes
And then I'm going to add in the
Req.params.dishId
So this will send back
saying post not supported on dishes/23 in the reply message
Now for PUT For PUT we'll say res.end and say Will update the dish
Req.params.dishId
Or rather we'll do it this way
I'll first write So res.write can be used to add
a line to the reply message
So we'll say updating the dish
And we'll say req.params.dishId
And since this is a PUT operation and
if the body contains the JSON string which contains the details of the dish I can extract the JSON string because
we are using the body parser
So we'll say Will update the dish:
Which dish? req.body.name
Plus
With details req.body.description
Now when we update the dish
I want to add a New line there
So I'll say '/n' there
So when you do a PUT you are sending back
the information about which dish ID you are updating and also
the details you are updating
The name and the description which should be in the body
of the PUT message there
For delete It'll say Deleting dish
and req.params.dishId
And so for delete this is
the operation that will be performed
So you see that now we have the get
put post and delete operations on the dishes/dishId
endpoint and also the get put
post operations on the /dishes endpoint
So let's now save the changes
And start our server again
Start the server by saying npm start
Let's now go to postman and
send a few requests to this server and see what it returns
Let me first issue a get to local
host 3000 and see what it returns
So when you send a request
to get local host 3000 it is still returning
the index start HTML page because the static file
handling is still in place
Now let me send a get request to
localhost:3000/dishes and this as you expect will send back a reply
saying we'll send all the dishes to you
Now let's send a POST request
to localhost:3000/dishes
So this is where you can change the
various methods that you want to execute
But when you send a post you want to include some details
in the body of the message because there's somebody's expecting you to send
information in the body of the message
So click on body here and
click on raw here
And then for the text
you select this to JSON so use the application JSON
So the content type would
be application/JSON in the request that you send
So since this is a JSON object so within braces I will say name
I'll just simply type in test and description
Some standard information here so
you see that this is a JSON string which contains two properties name and
description and the corresponding values
So let's send a post
request to the server
When you send a post request
to the server as you see in the reply it says will add the dish:
test week details: description
So as you can see the two piece of
information are extracted from the body of that JSON requested and
then included in the reply
Let's send a put request to dishes
When you send a put request to dishes
as you see it says PUT operation not supported on
/dishes and look at the status here
It says Status: 403 Forbidden
So this operation is not
allowed on this endpoint
Let's do a DELETE operation on the dishes
When you DELETE operation on the dishes then you will notice that it
says deleting all the dishes
So that's the reply that you get back
So you see that the get post put and delete on the /dishes
endpoint works as you expect
Now let's do a get on dishes /23
So 23 here is the parameter the ID of the dish that you want to get
So when you send a request to
that the server will reply will send details of the dish: 23 to you
So you see that the parameter has been
extracted from the request message and then included in the reply message
Let's do a post on this
And as you know POST is not
allowed on this endpoint and so that's why you get a status
403 Forbidden on this
Let's do a PUT operation on that
So for the PUT operation you notice
that the body still contains that
So in POST when you type in a value here that will be retained and can be included
in other requests that you're sending
So when you send a PUT request
on the endpoint dishes/23
So you notice that it says
updating the dish 23
Will update the dish
the name of the dish with details
the description of the dish here
And then let's do a delete
operation on that endpoint and then it says d deleting dish: 23
So those endpoints are all supported
as you see in this example here
So we have done get PUT POSRT and delete
operations on both the /dishes endpoint and also the /dishes/
the dish id endpoint
So you see how we have implemented
the REST API endpoint support for one set of REST API endpoints
Now with this we complete
the first part of this exercise
So here we have seen how we can
use express to construct and implement the REST API endpoint for
the dishes
Now this is a good time for you to do a git commit with
the message Express Simple REST
According to the terminal
I will start the Server
Check that three of
the items have been changed
So git add git commit  m Express Simple REST And check the set
So as you can see using Express you can
easily implement support for REST API
And as you can see from this list
you construct the app get PUT POST and delete methods for
all the REST API endpoints like this
Now imagine you have
a thousand REST API endpoints and you need to construct
something like this
Your index.js file will explode with so
many different REST API endpoints
And each one being handled
using its own app.get app.put app.delete and app.post
Now Wxpress supports a way of
subdividing this work into multiple many Express applications which then can be combined together to
form the overall Express application
This is where we will make
use of the Express Router to be able to construct
a mini Express application
And then inside a Express Router file we will support the REST API endpoint for
one group of REST API parts
So for example for
dishes and dishes dishId they can all be supported in one file
Similarly in the assignment
you'll be supporting a REST API endpoint called promotions and
promotions/:promoId
And then
you'll support another REST API and for leaders/leaders and /leader:leaderId
So each of these groups can be
implemented separately as many Express applications using Express Router
So that is what I will
illustrate to you for the dishes endpoint in the next
part of this exercise
So to do that we realize that if we
put all the files in one single folder then again your folder
structure will look messy
So my preference is to create
a folder here named routes
And this routes folder will contain
all the routers that I'm going to design using the Express Router
So in the routes folder
I'm going to create a new file called dishRouter.js
And this dishRouter.js file will contain the implementation of the handling
of REST API endpoint for /dishes and /dishes:dishId endpoints
Now how do we make use of Express Router? Let's see how we can use it
Now Express Router comes together with
Express so we don't need to install yet another Node module
Instead we can work with Express
that we have already installed
So to do that at that prompt
type const express = require('express');
So notice that
since this is a mini application we still require express even
in this dishRouter.js file
And from your knowledge of Node modules
once you define a new file that becomes its own Node module
And this Node module can then
be imported in index.js
So you see the connection already
between how we can restructure our application into multiple
files using Node modules
So we'll set require Express
then we'll say const bodyParser require ('body parser')
So we have already installed bodyParser
in the previous steps of the exercise so we can use that
Now to use an Express router let me declare const
dishRouter = express.R
And on express it supports this
router interface so we'll simply say express.Router and this will declare
dishRouter as an Express router
So in many Express application an insight here I can handle that
dishRouter related code here
So once I declare of this an in Express
router then I can say dishRouter
And then on the dishRouter
it supports a method called route method which can take in
an endpoint as a parameter
So I would simply declare
this endpoint a /
Now you're wondering
shouldn't that be dishes? You will pretty soon see
that I need to mount this Express router in my index.js file
So in my index.js file I will mount this
express router at the /dishes endpoint
Mounting of an express router again one more concept that I
want you to understand
Again I will illustrate that
to you in a short while
Now the dishRouter.route means
that by using this approach we are declaring the endpoint
at one single location
Whereby you can chain all get PUT POST delete methods already
do this dish router
Now when you look at index.js
look at the way we implimented this
So we have app.all and then /dishes
app.get/dishes and /dishes
Now if you had made a mistake
and their instructing app.post /dishes instead if you just type /dish
then what happens? The POST operation will not
be supported on dishes but will be supported on /dish endpoint
To avoid this problem the express
router supports this route end point
On the route end point you simply specify the end point on
which this router is going to work
And then the get put portion delete
method this simply chained into that
So it'll be one group of method
implementations all together
So that is the reason why
they use a Express router
So it comes with a couple of very useful support to make sure that your
implementation is correct
So now that we are going to
do that as the dish router what I'm going to do is I'm going
to remove this thing from here
Now that dishes IDN point
I'm going to leave that to you as an exercise in
your first assignment but the dishes endpoint I'm going to
cut this out all the way up to all
I'm going to cut this
out from index.js5 and to move that into the dishRouter here
Now when I move that into the dishRouter
I don't need this app.all anymore
I simply chain that into the route
so I will simply say .all and then I no longer need this
end point definition there
That's it.
So it'll say .all and
then we'll say req res next
And this all is operating
on this particular endpoint already specified here
Now not only that
we can chain the remaining methods
So that's why you see that I have
removed the semicolon from here
I'm going to delete this app and
then attach it on to that
So does get also gets changed into
the route and then I can remove this part the handling will
remain exactly the same as before
So similarly
I will remove the App there
And then again delete that from post
And the same thing
For put And for delete Same thing
So notice that there is no
semicolons here here or here but the last one the delete
will have the semicolon in place
So this group is one single
unit implemented by using the dish router on this particular router
and all these are chained together
And also of course with delete
I need to remove this end point
That's it see
clean structure of the code here
So that essentially ends up
implementing the dishRouter right remember this dishRouter is defined
inside the dishRouter.js file
Now I need to export this
from this node module
So to export this
I'll go to the bottom here and I'll say module.exports and say dishRouter
That is it
So now my dishRouter is
exporting everything that I need
Now you are looking at this and
saying what about Colon dish
That is going to be part
of your first assignment
Not only that you'll be implementing for two additional REST API endpoints also
the promotions and the leaders
But this already shows you
the structure of what a Express routers implementation of
res API support looks like
So this is for dishRouter.route
And one last thing before I forget we should say
dishRouter.use(bodyParser.json())
Now once you have completed
implementing the dishRouter we can now go in to the index.js file
Since this dishRouter is another node
module a fine node module nevertheless
So we need to import this
into our application
So right here I'm going to import const dishRouter is equal to require
Now since this is a file
based node module I'll say ./routes/dishRouter
And once I have declared them there
then I come down into the code here
And right there I say app.use
And I mount the router at an endpoint
So how do I mount the router? The first parameter here
I will specify slash dishes
And the second parameter
specify dishRouter
And that's it
So what this means is that
in my express application any request coming to that slash dishes
endpoint will be handled by dishRouter and that'll be done by
the code that is present here because we have said dishRouter route
and so notice that this says slash so which means that this is mounted
at the slash dishes endpoint
So that's why anything coming through
slash dishes will be sent over to this and will be handled by this
A big hint for
you to think about how you would implement that colon dish id end point
You will still use the same dishRouter.js
file to also implement the support for that /dishes/:dishID end point
That's another big hint for you okay
With these changes
let's save the changes that we have done to our application and
then restart our server and then take a look at how our
server is going to do its work
Going to the terminal let me restart
that server by typing npm start
And once the server is up and running
I'm going to go to postman and send requests from postman to this server
Going to postman now I know that
my server is only supporting the dishes end point
I have implemented the dish ID part of it
So let me send a get request
to local host dishes and you'll see that it works
exactly like before
Now if you have done a previous request in
post then you can simply click on that and then resend that request
Put operation doesn't work
post operation Works as you see there
And then let's cause the delete
operation on the dishes
And it says deleting
all dishes as expected
So this is the implementation of the rest
API support using express router
With this we complete the second
half of this exercise
This is a good time for you to do a get
comment with the message express router
Now that we have completed this exercise
where we have seen how Express can be used to support implementation of the
Res API end point support on our server and also the use of Express router it's time to move onto the first
assignment which follows this lesson
In the previous module we have seen
how we can make use of Express and Express router to build up a web
server to sum up Rest API
We constructed the entire web server by
hand and organized the files by ourselves
Wouldn't it be nice if we had a tool
that can automatically generate a standard structure for
our express application
Just like we had for angular or ionic or native script in the previous courses
some kind of command line interface that enables us to automatically scaffold
out a start up application and then you can go in and
modify the application to suit our needs
So that is where Express Generator
comes to our aid
Express Generator is a tool that we will
install a command line interface that we will install as a global NPM module and it enables us to quickly scaffold
out an Express application
Let's look at some of the details next
So as I said
what exactly is Express Generator? Express Generator is a quick scaffolding
tool that will help us to quickly build up the structure for an Express application
with some starting code already built and some standard middleware already
included into the application
And so all that we need to do is
install the Express Generator
Command line interface as
a global NPM module and then use that to scaffold
out our Express application
So how does Express Generator work? With Express Generator once you have
installed the Global API module
You just type Express space and the name of your Express
application that you want to start
And this will generate a folder with the name of the application
that you have typed in
There are various options available for
you to generate your Express application
It can use different kinds of view
generators like jade EJS and so on
If you're not familiar with them don't
worry about that too much for the moment
In this course we will be using Express
purely as a server that supports REST API
The client side implementation we are
already doing that using either angular Ionic or
native script in this specialization
And once you scaffold out your
Express application you just move into the replication and do an NPM
install to install all the preconfigured modules that are already included in
your default Express application
And some of the middleware that
by default will be included into your application
Once that is done
then it is just a matter of going in and modifying that generated
templates to suit your needs
So what is the typical Express Generated
application look like? So this would be
the directory structure or the folder structure generated
by Express Generator
So you have an app.js file which is
the starting point of your Express application and
then you have package.json which obviously contains the details
because this is a node application
So this contains all the details
of the dependencies and so on that will be installed
Then you have public folder
where you put your static resources
Then you have the routes folder where you have the various application
routes the REST API adopts
Now if you recall in the Express
application that we generated earlier I explicitly created the routes folder and put all the Express router
files into that folder
The reason is simply to keep match with
what Express Generator actually generates
When it scaffolds out an application
And then the views is where you have the
template engine for generating standard web templates HTML templates
if you are interested in using them
In this course we will be using the views
for our Express application in NAV
With this quick understanding
of Express Generator let's now install
Express Generator in our computer
And then use it to scaffold
out where several application that we will develop over
the rest of the course
Now that we have learnt about Express Generator the scaffolding tool for experts applications let's install Express Generator and then create a new Express application
We'll be creating the exact replica of the Express REST API application that we implemented in the previous module
We'll be indeed reusing the three routers Express routers that we implemented in the previous Express application in the newly generated application that we are going to generate using the Express Generator in this exercise
To get started your first step is to install the Express Generator
So at the prompt type "npm install  g" to install it as a global NPM module
We'll say Express Generator and hit the Return
Now if you're installing on a OSX or a Linux Machine make sure to use sudo in front of this command
Then install the application as a global application
As you can see the Express Generator version that I'm using is 4.16.0 in this course
Now that we have installed the Express Generator in your terminal move to the Node.Js folder where you have been storing all the various node applications that we've been developing in this course in the Node.Js folder
At the prompt type express conFusionServer
Now if you've been following from the previous courses you understand why I call it conFusion and so let's scaffold out our express application in the conFusionServer
I'm scaffolding out without any new options and then within a short while the Express server will be scaffolded out
Now move into the conFusionServer folder and then you would see that a bunch of files are already been scaffolded out for you
So let's open this project in Visual Studio Code
Also at the prompt type "npm install" to install all the NPM modules that are already included in the package.json file
So let's take a quick look at the package.json file to see what are all the various NPM Node modules that are going to be installed
Going to our application in the package.json file you see that the server with the default name has been scaffolded out and you see a bunch of dependencies that are declared here
So all these NPM modules are going to be automatically installed for you by NPM when you type "npm install" in this folder
So you will see the Node modules folder being created here
Go into the terminal type "npm install" and then let it proceed with installing all the various NPM modules
Once they are all completed then we are ready to get started with our Express application
You would notice that the default Express application has already been installed
So at the prompt if you just simply say npm start the default application will start up and you can browse using your standard browser to see what this application serves up
Go into Postman at the address block type localhost:3000 and send the request and you will see that your server will return this default information from the server site
So this is the standard Express server that is scaffolded out by Express Generator
On the console you'll see information like this printed here
This is what Morgan prints out on the screen to show the requests coming in
So it shows the type of request to which URL and the corresponding response that has been sent back to the client from the server
Let's stop the Express server
Let's initialize a Git repository and then we'll check the Git status and you'll see that the node modules is being included
So let me switch over to my application and then create a gitignore file and then in the gitignore file let me specify the node modules as a file that I want to ignore
Then coming back to the terminal let me check the git status and you see that now we are going to be checking in only those files that are part of our application
So at the prompt type git add and then say git status and you see all the files have been checked in
So you say git commit  m "Express Generator"
Now we're going to continue with this Express application
We had already built the three routers using the Express router in the previous Express application that we implemented
We're going to copy over those three routers to this application that we generated using Express Generator and also set up this application to make use of those three routers
So to do that let me go to the Node.Js folder and then going into the node express folder and routes I'm going to copy the dishRouter.js leaderRouter.js router.js and promoRouter.js that I have implemented in the assignment and we'll come over to the conFusionServer that I have just created and into the routes folder and then copy over those three Express routers that we created there
So automatically now modifying the app.js file we will be able to support the REST API using the Express application that we have just scaffolded out
Paying a quick a visit to the application that has been scaffolded out
As I mentioned in the previous lecture the app.js is the place where it all begins
So this is the standard file so you can see some of the things that you're familiar with from the previous module
So we are requiring express path logger which is morgan in this case
CookieParser which we will use in one of the later exercises and you also see that you are importing two routes; the index and the users which are already scaffolded out by Express for us
So we will add in the three new routers here
So I'll just say var dishRouter require routes dishRouter and then they will copy this and then also import the promoRouter and the leaderRouter and we will set these up to be used here
Here you see that the index is mounted at the slash and then the users is mounted at /users
So we'll say app use and dishes dishRouter
It's Four O'clock
Promotions promoRouter and leaders
LeaderRouter
That's it
Our Express application that has been scaffolded out is now all set up to be a full fledged REST API Server which will serve up for dish dishes promotions and leaders
Now if you browse through the rest of the code it'll look all familiar with a few new things in there
We will visit them as and when we require to understand a bit more details there
So you can see that the static server has been setup the logger has been set up there and some of this other  so this one is a global handler for errors
We'll see how to make use of it in more detail
And these two are additional error handlers that follow after this
We will see how we make use of them as we implement further in this application
So this is where you notice all this information
Now you're wondering where the server itself is configured to the local host and the port number are configured
Now this information is in this file called bin/www
If you open the bin/www folder you will see additional information here
So it says var app require.
slash/app
So from the bin folder you come up here and then this app.js file is required here into this; and so that will automatically include the express and everything
And then in here you're setting up the http server here and you're setting up the port number
You can also supply your own port number at the command line but at the moment we are going to use the default value which is 3000 and we'll set up the port number here; and then you see the var server http.createServer that you have seen earlier and the server is listening for things here
And then also here are some listening for events on the server side
We'll come back to this in one of the later exercises
And then down below you'll see some additional code that sets up your server to be able to handle errors and listen for incoming requests on the port number and so on
At the moment don't worry too much about this code
We will revisit this code whenever we require and we will be modifying this code as and when we require in one of the later exercises
So that is where your server information is all set up there
And app.js we have already seen the routes folder there
Index.js and users.js are two default routes that are set up already for us
We will be using the users.js in one of the later exercises
And in the public folder let's go ahead and copy the index.html and aboutus.html from our Express application into the public folder also
So going back to the node express public folder
I'm just going to copy these two
And then we'll come back to the confusion server; and then in the public folder I'm going to simply paste them into place
For the moment these are placeholders
Later on we will be replacing them with other things
So with these changes our server is now fully set up to run as a REST API Server and will support all the REST API endpoints
So let's start our server
So at the prompt type npm start and your server will be up and running
Let's go to PostBin and send a few requests to this server
Let's now send a get request to local host 3000/dishes and you will notice that the REST API Server is working exactly as we expect
We send a request of delete and it will delete the dishes
And then let's send a delete request to promotions and you see that it works just like before
And we do a post to promotions with the body fielding and send the post request and you will see that it says "We'll add the promotion test with detailed description." Let's send this to leaders.23 but put request to leaders.23 and you should see that it says "Updating leader 23
Will upgrade the leader." So you see that the Express generator that generated the application and we have modified it to support the entire REST API endpoints that we configured in the previous version of the Express router
Now with this we complete this exercise where we have demonstrated how we can use the Express generator to build up the REST API endpoint
Now this is a good time for us to do a Git Kermit of the changes with the message "Express generator REST API."
Let me give you a quick overview of MongoDB
Why is MongoDB interesting? How is it useful for our application? And what are some of the salient features of MongoDB in contrast to traditional SQL databases? So this will not be an entire treaties or databases
I assume that you have sufficient knowledge of databases
So what I would introduce what MongoDB would be easy for you to follow
From your prior knowledge of databases I assume that you already understand that databases are used to store structured data and also enable you to perform various operations of the data including querying the data inserting records into the database updating an existing record in the database or deleting a record from the database
The typical crud operations that are supported on databases
Structured Query Language or SQL based databases have been very popular for a long time as a means of storing data
The MySQL is one example of SQL based database
They have been very effective in storing data and then addressing many of the needs of applications
Indeed many websites already use SQL databases as the backend for storing data given that why is no SQL databases important with new kinds of applications that are coming online
There is an increasing demand for new features not all of which the SQL based databases can address
So this is where the NoSQL based database are not only SQL based database are gaining a lot of grant MongoDB being one example of that
So the NoSQL databases are designed to address some of the shortcomings of SQL based databases
The NoSQL databases themselves can be classified into four different categories
We have document based databases like MongoDB we have the more simpler key value based databases like Redis column family based databases like Cassandra and then the newer graph databases like Neo4J and indeed there are more now in the market than these examples that I have given
But of course in this course we will be concentrating primarily on document based databases MongoDB in particular
So I will review more about MongoDB in the rest of this lecture
Document databases as the name implies are built around documents
A document is a self contained unit of information and can be in many different formats JSON being one of the most popular formats for storing documents in a document database
As an example a JSON document is shown here and this would be something that are bestowed in a typical document database
Documents themselves can be organized into collections
So a collection is a group of documents and in turn the database itself can be considered as a set of collections
So these terms "Documents collections" and "The database" will occur frequently when we discuss about document databases and MongoDB in particular
Why are NoSQL databases of interest to us? In particular scalability is one of the reasons why NoSQL databases have shined very well
Now in terms of scalability when we look at the two requirements; availability and consistency of the databases typically SQL databases find it very difficult to meet both requirements simultaneously
So there is a tradeoff between availability and consistency
So this is where NoSQL databases have been a lot more successful at meeting both the requirements
This is where the third aspect highlighted here partition tolerance also comes into effect
Now partitioning a SQL database and then distributing it is not as straightforward
Whereas a NoSQL database is lot more amenable to being subdivided and then distributed across multiple servers
The second aspect of why NoSQL databases have been popular is ease of deployment
When you use an SQL database there is a need for matching the records in your SQL database back to objects in your native language like Java or Javascript and so on
So there is a need for object relational mapping and this is where an intermediate gateway needs to fill in this requirement
With a NoSQL database like a document based database storing data in the form of JSON the mapping becomes quite straight forward and that is one of the reasons why NoSQL databases have been very popular in the web development area
Coming to MongoDB in particular MongoDB is a document database
The server itself can support multiple databases
A database in particular is a set of collections and the collection itself as we discussed earlier is a set of documents
So the document becomes the unit of information in case of MongoDB
The document in MongoDB is nothing but a JSON document
In fact MongoDB stores the document in a more compact form called as the BSON format
We'll talk about that in the next slide
While MongoDB is a document based database it stores the JSON documents in a compact form called as the BSON format or the binary JSON format
Now this supports length prefix on each value so that skipping over a field becomes lot more easier
So as you see MongoDB supports additional features than a simple document database
The information about the type of a field value is also stored
And in addition within the JSON document additional primitive types are stored which are useful when you are performing operations on the database
Things like the UTC date format it also supports raw binary and also uses an object ID format for storing the ID of each document in the database if you choose to
Let's talk about that in a bit more detail in the next slide
Let's talk about the MongoDB object ID
Every document in MongoDB database must have an ID field an underscore ID field which acts as the primary key for the document
And this field is unique for each document
The ID field itself can be used in many formats and one particular format that MongoDB automatically assigns in case you don't choose to use your own ID field is the object ID that is created by default by MongoDB
So the object ID itself is a structured piece of information but is stored as the ID of the document
As an example the ID field that is automatically assigned by Mongo in case you don't specify an ID field contains the object ID in the form of a long string
Now this string has a specific format which enables it to store a number of pieces of information within the object ID
Let's look at the structure of the object ID itself in the next slide
As I mentioned the object ID field itself is a 12 byte field which stores information in a specific format
The first four bytes includes a timestamp the typical Unix timestamp in the resolution of a second
So this is told in the first four bytes
Then the next three bytes towards the machine ID the machine on which the Mongo server is running and the next two bytes is the process ID the specific Mongo process which has created this document and then the last field is an increment
Now as you understand the timestamp field itself is at the resolution of a second
So if you have multiple documents that are stored within the same second then the increment field will distinguish among the documents
They increment field is a self incrementing field
So each new document created within a second will get a new increment value
So combined together with these two you can easily distinguish between different documents that are stored within your document database
So this enables you to clearly give a unique ID to each document
Not only that given an ID you can easily retrieve information from this ID
So for example you can get hold of the ObjectID and then call the getTimestamp method of the object ID and this will return the timestamp in the ISO date format
So that will enable you to identify when this document has been created
With this quick understanding of MongoDB let's proceed on to the exercise where we will first install MongoDB on our computer and thereafter interact with the MongoDB database using the Mongo ripple the read evaluate print loop that Mongo supports
Now thereafter we will look at how we can access the Mongo server from within our node application in the next lesson.
 Now that we have had a brief introduction
to MongoDB it's time to get hold of MongoDB install it on our computer
and then interact with MongoDB server
To get started of course the first thing
is to install MongoDB on your computer To install MongoDB on your computer
go to mongodb.com
And on the right hand side here
you will see the Download button
You can click on the Download
button in order to obtain the links to that download
So when you click on the Download button
you'll be taken to the Download Center where you would see various versions
of MongoDB available to us
You can access it online
using database as a service
But in our case we're going to download
MongoDB and install it on our computer
So to do that we will choose
the Community Server version of MongoDB
And when you do that you will be
automatically given access to the specific version suited for your computer platform
So in this case I'm going to download
the OSX version of the MongoDB and then do the installation
If you are using a Windows machine then
you can download the Windows installer
For a Linux machine correspondingly you can download
the corresponding installer here
To install MongoDB the MongoDB documentation itself
provides you with detailed instructions
I don't think I can give you any
better instructions than what is already provided there
So to understand how to install
MongoDB on your computer head over to
docs.mongodb.com/manual/installation
And then click on
the Install MongoDB Community Edition
And here you will see the installation
instructions for various platforms
So to install on Windows
click on the Install on Windows and then go through the steps given here
And they specify how to
download MongoDB and then install the MongoDB Community Edition
on your computer
So go ahead and follow these instructions
to install MongoDB on your computer
And also they tell you how
to get started with MongoDB
Now once you have
completed the installation you can proceed ahead to the next
step that we gave in the exercise
Similarly if you are installing in OSX just follow instructions given
here to install it on OSX machine
And also correspondingly for
the Linux platforms
I assume by now you have installed
MongoDB following the instructions given in the documentation
Then once you have completed that go to
a convenient location on your computer
So here I am in my Coursera folder
I'm going to create a new
folder here named mongodb and then inside the mongodb folder I
will create a new folder named data
Now this data folder is where
mongodb will install all the data relevant for my current project
Once you have created this folders
open a command window or a Terminal at the mongodb folder
So here I have my Terminal and I am currently in the mongodb
folder that I have just created
So at the prompt in order
to start the Mongo server type mongod   dbpath =data   bind_ip 127.0.0.1
Recall that we already have the data subfolder inside the mongodb folder
So the dbpath here essentially
takes the path to the folder which will store the data for
my Mongo application
Now you can execute this mongod command
from any location on your computer
As long as you specify the complete
path to the location of the data folder where your MongoDB
data is going to be stored
Since I am already in the mongodb folder
and the data folder is a sub folder
of the mongodb folder I can just simply execute the command
by saying mongodb    dbpath=data
And this should start
up your MongoDB here
And if it asks for some permissions
just allow MongoDB to be available for being connected
to from different locations
Open another Terminal window or command
prompt and add the prompt type mongo in order to start the Mongo report or
Mongo read evaluate print loop
So this is a command line way
of accessing your Mongo server
So when you type Mongo
it will automatically connect itself to the MongoDB server that is running on
your computer at the port number 27017
So here
you see this is automatically connecting
So when you start the Mongo Ripple
it will know exactly where to look for the default MongoDB server which will
be running at port number 27017
In this course we're going to be running
the MongoDB server at its default port number and so
that it's easy to access data
Also on OSX machine you might see a warning like this
which says soft rlimits too low
You can just ignore that warning
everything will work just fine even though you will see that warning
being printed there
This has something to do with the amount
of memory space available for your Mongo process
And this will be just fine to run for the development version of the Mongo that
we're going to be using in this course
Now once the Mongo Ripple starts
you will see a prompt and at the prompt you can type various commands
to access your Mongo server
So at the prompt if you type db
it will specify the specific database on the Mongo server to
which it is currently connected
So now we're going to create a new
database there with the name confusion
So to create a new database I would
just say use conFusion at the prompt
So this will automatically create a new database named conFusion
if it doesn't already exist
If it exists then it will automatically
switch to that conFusion database there after any commands that you execute
will be accessing this conFusion database
So at the prompt if you now type db you
will see it prints out saying conFusion
The test that it printed earlier with the
test database that is automatically set up when you start running the Mongo server
Now to learn the various
commands that are supported you can just type db.help() at the prompt
And this will print out a set of
commands that are available to you at the Mongo Ripple command prompt
We're going to be using a few of
these to access the MongoDB database
Again typing db you see that we
are accessing the conFusion database
Let's create a new collection
in this conFusion database
To do that at the prompt type db.dishes
Now the dishes here
refers to a collection
Now if this collection already exists then this will access
the dishes collection
If it doesn't exist then it'll create
the dishes collection at this point
So in the dishes collection
I'm going to insert
So this is where we use the insert function that is available
on the collection here
And then let's insert a record
into this collection or a document into this collection
So at the prompt I'll type name I'm just typing some random stuff
here just to show you that we can insert a document into the database
So with this this particular
JSON document that you see here will be automatically
inserted into the database
So the insert function
takes a JSON document as its parameter here
And immediately the Mongo Ripple will respond saying WriteResult and
number inserted is 1
So one record has been inserted one document has been inserted
into this collection
Now to print out the various
documents in this collection we can simply say db.dishes.find()
So the find function will find all
the documents in this collection and it will print out those documents
Now if I just say find then it will
print out this information like this here as a single line and you can see
that this is a JSON string here
Now we can also use the Pretty function that is available
which will print out the documents in a more easily readable manner
So if you type db.dishes.find().pretty()
so you see that the document that we had
inserted earlier Is now seen here
So you can see that the name and the description that we had inserted
is available in this document
In addition note how MongoDB has automatically
added an id field to this document
So if you don't explicitly
specify the id field MongoDB will automatically add the id field
And as explained in the lecture earlier
this is of the type object id and you can see that this string specifies
the ObjectId information there
Now this ObjectId as we learnt
in the lecture earlier has a specific fall back which
it also includes the timestamp the machine name the process ID and also the increment value
that is stored here
So now similarly if you want to I can simply create an object
ID using the Mongo Ripple
So let me just type var id = new ObjectId(); just to
demonstrate to you that the ObjectId will contain the timestamp
So here I have created this variable
them ID which is a new ObjectId
Now I can simply type
id.getTimestamp(); and you will notice that this
will print out the current time value in the ISO
format as you see here
So this shows you that the ObjectId
actually contains the timestamp field here
So similarly you ask for
the other fields also from the ObjectId
And to quit the Mongo Ripple
just type exit at the prompt and the Mongo Ripple will exit and then bring you back to your Terminal
prompt or your command prompt
With this we complete this exercise
In this exercise
we have seen how we download and install MongoDB on our computer
How we start up a MongoDB server
and then access the MongoDB server using the Mongo Ripple and
interact with the server
In the previous lesson we learned about
MongoDB we downloaded an in store MongoDB and interacted with the Mongo
server using the Mongo ripple
But of course that is not the way we
envision using MongoDB in this course
Instead we want to be able to access
the MongoDB server from within our node or express application
So how do we access the Mongo server
from within our node application? So this is where we have a node JS
based driver that is officially available from the Mongol Developers
that we can make use of connect to the Mongo server
from within our Node.js application or
within our expressive application
So let's learn a little bit more about
that Node.js and MongoDB climber
So as I mentioned the Node MongoDB Driver
provides a high level API that enables you to access the Mongo
server from within your Node application
And it provides you with many
methods that enable you to interact with your Mongo server
Now to install that MongoDB
driver which is a node module we type npm install mongodb and   save
to install it within our application
Thereafter we will then develop
our Node.js application and then require this app
MongoDB driver and they make use of the node module to access the MongoDB
server from within our application
The MongoDB driver which is nothing but
a node module provides several operations that can be carried out on the MongoDB
server from within our Node application
It allows you to connect to the MongoDB
server obviously and thereafter allows you to perform various database
operations like inserting deleting and updating an existing record or
adding new records to your database
Also it provides various base of
creating the documents that already within the database
We will look at some examples of how they
make use of the various metrics that the MongoDB Driver provides for
us in the exercises for this lecture
Now the driver itself supports
both callback based and promise based interactions
with the MongoDB server
So let's look at some details
of this in the next exercise
Now that we have learnt about the node MongoDB driver the node module which enables our node application to be able to interact with a MongoDB server in this exercise we will use the node module and use the various methods that are supported by the node module to provide introduction with our MongoDB server
To get started go to the NodeJS folder that you have been using to store all your examples and then create a new folder there named node mongo
In this folder we will develop the NodeJS application that interacts with our MongoDB server
Now make sure that your MongoDB server is up and running so in the previous exercise we have already seen how our MongoDB server can be started
So keep the MongoDB server up and running and in other terminal window or terminal tab or command window go to the node mongo folder that you have just created and initialize a node application here
So let me type npm init and we will name the application as Node Mongo and version description Node MongoDB Example and the entry point and the author just like we have been filling in the previous exercises
Then once the package.json file is initialized open this in the editor of your choice
Now going into the package.json file let me introduce another script here just like we have been doing earlier so we'll say "start": "node index" and save the changes
Going back to the terminal let's install the MongoDB node module
So type npm install mongodb@3.0.10   save
We will also install the assert node module so we'll say npm install assert@1.4.1   save
The assert module enables us to use the assert to check for truth or false values within our application and you will see me using it later
Now that we have installed these node modules let's create our node application that interacts with the MongoDB server
Going back to the editor in the project folder create a file named index.js and this is where we will create the node application that interacts with our MongoDB server
So in this application let's type const Mongoclient and then they'll say require( `mongodb`) the MongoDB node module that we have already installed and then this would provide us with the MongoClient that enables us to connect to the MongoDB server
Also require the assert module
Now to start up a connection to the MongoDB server let's create a constant name URL which will be the URL where the MongoDB server can be accessed and the baby access this is by saying mongodb://localhost: 27017/
Recall that this is the port number at which your MongoDB server is running 27017 const dbname= and then they we'll say conFusion
Recall that we created the conFusion database in our MongoDB server in the previous exercise so we're going to access that the conFusion database that we have created earlier
Now to access the server we`ll say MongoClient.connect
So the connect method allows us to connect to the MongoClient from our MongoDB server and then we'll say this takes the URL as the first parameter the URL of the MongoDB server as the first parameter
The second parameter is a callback function
So the callback function has two parameters the error value and client which we can then use to connect to our database and then perform various operations
So inside this callback function first thing that we will do is to check to make sure that the error is not null
So the assert will check to see if error is equal to null so the assert function allows us to perform various checks on values
So we check to make sure that the error is not if it is not null then that means that there is an error and so we will show the error on the screen
So that's the use of the assert function here
Now if that doesn't happen then that means that we have connected properly to the server so we'll say `connected correctly to server` const db= client.db(dbname) to connect to the database then we can say const collection db. so the db will provide us with various methods that enable us to interact with the server so we'll say db.collection(` dishes`) So we'll try to access the dishes collection within this database
Now the next thing that we will try to do is collection.insertone so we will try to insert one object into the collection and this object would be with the name and description "test"
So this collection provides this method called insertOne which allows us to insert one document into this collection and the document is the first argument to this method here
The second argument to the method is a callback function and the callback function takes two parameters error and result
So within this callback function if the result is obtained then we are able to access the collection and then perform further operations
So here the first thing that we will do is check to make sure that error is not null
So we'll do an assertion there and then here we can say "After Insert"
So after we insert then we see that we get the result value that is returned there so this result
This result will also provide this OPS property which says how many operations have just been carried out successfully
So that is what I am going to print out
So it will say number inserted is one
So which means that this particular document has been inserted into the database
So that's what we will confirm here
Then after that we will perform another option an operation on the collection and say collection find and we'll try to search for all the records in the collection
So here we will supply an empty JSON string or corresponding level JavaScript object
So it will search for everything that is there in the collection and then provide that to us
Then this can be converted to an array of JSON objects
So this is why we call the toArray and this takes a callback function as the parameter
The first parameter of course is the error value so again we check to make sure that the error is not null
Then we'll say console.log found and then print out whatever that has been found and we'll say console.log
So the second parameter here docs will return all the documents from this collection that match whatever criteria that you specify here
Since this is empty then that means that all the documents in the collection will be returned to us
You can specify a filter here saying name is equal to a value and then only those documents that match that value will be retrieved
So here let me just print out the docs here to indicate that this item has been inserted into the collection and then will be retrieved and then we'll just print it out just to make sure that the document that we just inserted in the previous operation is indeed in the collection and so we'll print that out here
Now after this then we will use the dropCollection method here
So the dropCollection will drop the specified collection here
So we'll say dropCollection dishes so I'm just going to remove the dishes collection from my database
So I am just going to clean up the database and then leave it with an empty database so that we can go onto the next exercise where we can again perform similar kind of operations to check this out
This one takes as a second parameter a callback function which returns either an error or a result
Inside this we will check and make sure that the assert is not null and then we will say client.close
So we will close the connection to the database on the spot
So with this this simple set of methods enable us to interact with our server and also it demonstrates to us how we can communicate with the server using the methods that are available through this MongoDB node module or the MongoDB driver
So here you see that first we perform an insert operation
Then after the insert operation note that we are doing the second operation inside the callback function
So this ensures that this operation has been completed before you do the next one
So this is a second call which is enclosed inside the first callback function and then correspondingly inside of that
We are again calling the methods here and inside there
So you see that there is a nesting of these calls one inside the other
Note the structure because I'm going to come back to explain something about this in one of the later exercises
So note that nesting of these calls one inside the other
Let's save the changes and then see what this application does when we execute it
Going back to the terminal again make sure that your MongoDB server is up and running and so when it is running it is going to print out a lot of log messages onto the console
We can just ignore those log messages for now
Let's run the node application
So we'll say npm start and when the node application runs you notice what does node application is doing
So it says connected correctly to the server After Insert then it shows that this particular document has been inserted into our MongoDB and the node in particular the ID given here
So notice that this doesn't say this is a object ID
This ID is automatically inserted by the node Mongo driver into their document when you try to insert it into the MongoDB server here
This format is exactly the same as the object ID that we have seen
Thereafter we performed a find operation
So this is found and then it prints out this item here
Note that from the previous exercise we had left over in earlier document that we had inserted in the previous exercise
So that is still seen in the collection here and the new document that we just inserted here
This document is seen right below that here but note that these two have two different IDs
This ID matches the ID of the document that we just inserted
So this is leftover from the previous exercise
After this of course we drop the collection so this whole set of documents and the dishes collection will be removed from our database
So now our database will be clean and empty
So that demonstrates to you how we can use the MongoDB driver to communicate from our node application with the server
Now that we have our application let me introduce a.gitignore here and then put node modules into the.gitignore and you quickly understand why I'm doing this
Then we will go back and initialize the Git repository and then do a git commit
Going back to the terminal let me initialize the Git repository and then let's check the Git status and you see that there are some uncommitted files
So let me check them in and then do a git commit with the message Node MongoDB Example one
This is the part one of the exercise so we'll just check the items into our git repository
This completes this exercise
In this exercise we have seen how we install the node module the MongoDB driver then we were able to communicate with our MongoDB server from within our node application using the methods that are provided by the MongoDB driver
We will continue with this exercise in the next part of the exercise where we will explore a few more methods of the MongoDB driver.
In this exercise we will continue with the previous exercise where we developed the interaction between the node application and the MongoDB server
In this exercise I am going to encapsulate a few of the database operations into a node module of its own a file based node module and then make use of it within my node application in order to interact with the server
At the same time we'll perform several operations on the server to demonstrate that we will be able to interact with the server using our node application and the node MongoDB driver
To get started let's go to our project and then create a new file named operations.js
This file will encapsulate all that database operations the four operations that I'm going to perform insert find remove and update a document in my database
Now this will be organized as a file based node module which then I will make use of it in my node application to access the server
So to get started let me first require assert in this node module and since this happens to be a node module we'll be exporting several methods from the node module
The first method would be insert document obviously as you would expect and this will take four parameters DB the MongoDB database connection within my node application that I will obtain within the node application
Then the second one is the document which I want to insert
The third parameter is the collection into which I want to insert the document
The last one is a callback function which will be called back once that operation is completed
Then let's close the function here and this essentially encapsulates the insert document method here
So this is a function which is exported by this node module here
Now I'm going to also incorporate a few more methods here
The second one would be finddocuments
Not just one but several documents
This I would search the collection and find all the documents that are in the collection
So that's why I'm only taking the database and the collection as the two parameters along with the callback
The third function that I'm going to implement an export from here is the removedocument
This supports the delete operation and so the name of document will take the database the document the collection and the callback as the four parameters and we'll call the callback when the operation is completed
The final one of course is to update the document
Now of course you don't necessarily have to do it this way
I just felt that this would be another way of illustrating how you can encapsulate that functions into its own node module
This is just reorganizing the code in a way that is more easier to use
So for the exports for the update document it takes the DB some way of identifying the document as a second parameter
The third parameter is the update and the fourth parameter is the collection in which this document exists and the callback
So four functions to be exported by the operations.js file
Now within this functions let's implement one by one
In the insert document the first thing that I'm going to do is say const collection and it'll say DB collection and the parameter is the collection
So we'll look for the collection there
Now this has to be performed in all the four methods
So I'm going to go and paste this code into all the four methods here because that's a function that I need in all of them
So once I get hold of the collection then as you recall from the previous exercise I can perform operations on the collection
So I'll say collection insert and this takes as the first parameter the document to be inserted and the second parameter is the callback with the error and that result
So now when this document is inserted by calling the insert method on the database collection the insert method let me remind you is supported by the MongoDB driver
So that's the method that we're using here or that's the function that we're using here
Now the first thing that I'm going to check for this assertequal err null
So I want to make sure that I don't have an error
So I want to make sure that the error is null
If it is not null then this will print out the information and then quit the application
At this moment I feel that this is okay to handle it that later on we'll see how we can have a global way of handling all the errors when we implement in the next lesson another way of accessing the MongoDB database
Now after I do this I'm going to implement I'm going to simply log this information
So I'll say console log and insert it
So this information will be printed out to the screen here inserted
Now again remember the semicolons and all that are important don't forget them when you are typing in your code
So I'll say inserted result
This result object that is returned will have on it a property called the result property and this property will contain a value
This result property is also a JavaScript object and this will contain a property n which tells us how many documents have been inserted
So that's the information that I'm going to print out here and then we'll go to the next line and say "documents into the collection." Now this is just a way of informing the user that this operation took place correctly and then they will pass that result back to our calling function
So we'll call the callback and then the result will be the parameter to the callback
So when we implement the usage of this function in our index.js file we will be providing the callback there which will receive the result as the incoming parameter
So this is for the "insertDocument." Now for the "findDocument " what I am going to do is to say "coll.find" and I'm going to find all the documents
So that's why I will give an empty JavaScript object in here which will match with all the documents in the collection and then I'll say "toArray" and this will take as a parameter a callback function and inside this callback function of course I will assert that this is not null and then we will say "callback docs." We'll simply pass back the retrieved documents back to the calling function
Now for the "removeDocument" I'm going to say "collection deleteOne." So I'll try to find the first document that matches what we have specified and then delete it
And then this will take again a callback function as a second parameter and inside this callback function the first thing that I check is to make sure that the error is not null
And then after that we will say "console log removed the document comma document." We used the comma here because this is a JavaScript object so if you specify console log like this the document will be printed out and then we'll pass that result back through the callback function
And then finally for the update we'll coll.updateOne
This is a method the MongoDB driver supports
So I'll say "update.One document " and the second parameter is where we will pass in the fields that need to be updated
And the way it is done we'll say "dollar set colon update." So this will take the update information that I'm sending in and then pass it into the update.One
The first one is the document that needs to be updated
The second one is which fields of the document needs to be updated here
And the third parameter is null and that last parameter is a callback function which obviously will give us the result of the operation
So first thing I'm going to check to make sure that the error is not null
Then I'll do a "console log updated the document with." Now again the console logs are purely for us to ensure that the code is doing what it is doing
It doesn't help in any way
This is just for our own information
In a production server you would not be having this console logs maybe
You can disable them
So that's it
So four methods being supported in this particular file based node module insert find remove and update
So now that we have implemented this file based node module let's go to the index.js file and then to make use of that file based node module I need to require this here
So I'll say "const dboper require." Since this is a file based node module you get the full path to the node module and which in this case happens to be./operations because it is in the same folder as my index.js file
Now once we have done this then right here this function this code that we were doing to access the database now insert we will be using the dboper that we have just implemented to access that database
So we'll say "dboper insert document " and this "insert document" takes the db as the first parameter
The db here is this db that came in when we call MongoClient connect
So that db will be passed in so that way my operations node module knows where to access the database
Then the second parameter is the so if you look at the "insert document" you will see that the second parameter is the document to be inserted
So I will say "name
" I'm just going to construct a JSON object or JavaScript object here which will automatically be mapped into adjacent object when it is being inserted
And the third parameter as you see "db document collection and callback." So the third parameter is the collection and the collection is the dishes collection and the final one is the callback
The call back again as you recall receives the result
If you look back at the baby implemented the insert document the callback received the result as the parameter
So inside this callback we will handle that result value here
So when the result value comes in we'll do a console.log
We'll say insert document backslash N and we'll say result OPS
The OPS tells you the number of insert operations that were carried out
So this is another object that is going to be on the result JavaScript object that is passed back in as the parameter and so I'm just going to print out that value
So that'll give us some information about what has happened
Now once this is completed inside this callback function I'm going to call the next database operation
So I'll say dboper and then find the documents
Then I'll say dbdishes and the third parameter is docs which is the callback function
When I receive the docs I'm going to do a console.log saying found documents and we'll simply lock the documents to the screen
So this will print out the found documents
Notice that this call is inside the callback function that is applied for the earlier function call so that is something that I want you to notice specifically
Now again inside this function call they need to do it this way because until this callback is called we cannot do the next operation
So in that next operation I'm going to update the document that I have just inserted
So I will say update the document and I'll say Update Document DB and then the next parameter is the document and I don't need to specify the entire document I can only specify one field and then that'll find the document that matches this particular field
What I'm going to do is the next parameter is the update that needs to be supplied
So the update is which field I want to update so I'm going to update the description field by saying Updated Test and then the fourth one is the collection which is Dishes and the final one is the callback function which obtains the docs as the return value or rather result of the update operation that we just carried out
Then inside this callback function I'm going to again do a console.log saying updated document backslash N
The updated document will be passed back in result.result on this property of the result object that is passed tracking
Again notice how the calls are getting nested inside the callback functions here
I want you to notice this structure of the code specifically because that is what I'm going to come back to in the next exercise
Now after I do that I'm going to find the documents so let me just copy that and then I'm going to use the same code here
So I will say find documents
Inside here I am again going to say found updated document
Then finally when I'm done with this I will simply call db drop collection
So I'm going to delete this dishes collection so that I will clean up my database so that I don't have anything more because for the next exercise I want to clean up the database and then start with a cleaner database
So I'm going to clean out the dishes collection and then this would result in a callback
So inside here I'm going to do a console.log saying dropped collection and then I'll just print out the result that came in
Then finally close the database
Note that structure of the code DB insert document and inside the callback function I'm going to call the next function and inside the callback off that I'm going to call the next function and inside the callback next function and so on
So you see a nested set of callbacks here and a tree structured nested set of call backs here
That is something that I want you to pay attention to
Let's save the changes and go and look at this version of our application
Getting back to the terminal let me execute the application
So let me type NPM start and we'll see that result
Now from this result you can see that the document is inserted into the collection and that is the document that has been found
In the second step we are finding the document so when we call the DB find document so this is the document that is retrieved from my collection
Then I ask it to update the document with this and then you'll notice that it says updated document and then here it prints the result or OPS and it says N is equal to one number modified as one and it was okay
Then it prints out the updated document we find the updated document here and that is what is printed out here and note in particular that the description has been updated
Then finally it dropped the collection
So we see how this application runs and is able to make use of the node module that we implemented and then performed various database operations
With this we complete this exercise
In this exercise I have demonstrated to you how you would interact with your MongoDB server from your node application
We have implemented our own node module here and then used it within our node application by encapsulating certain of the database operations into that node module
This is a good time for you to do a Git commit with the message node MongoDB example part two.
In this lecture and the exercise that follows we'll talk specifically about Callback Hell
The problem that arises when you write callbacks in node and especially nested callbacks and node
We'll also look at promises as one way of addressing the Callback Hell problem
To give you an idea of what the typical Callback Hell problem will result in let's revisit the index.js file from the previous exercise
As I was talking about it in the previous exercise you notice that for each of the operations that we perform the subsequent operation is included inside the callback function here and so on until you form a pyramid like structure go again
So you see this pyramid like structure arising within your code
Now imagine that you need to perform multiple nested operations like this your code will become pretty soon very complex and not so easy to decipher
Now this is what in the node.js world they refer to as Callback Hell
There have been several ways of mitigating the problem that arises
Now you can completely avoid this because of the fact that you have certain operations that need to complete before the next operation can be initiated but we can rearrange the code in a way to mitigate this problem
Promises being one such way of addressing this
So to summarize what we have just discussed heavily nested callback code causes the Callback Hell problem and it results from our tendency to write programs top down
We are still hung up with our sequential way of writing code and so we see it more convenient to write code top to bottom and look at it as if it is executing in that order
Now we can work around the Callback Hell problem by not using anonymous functions for the callbacks but instead declaring those functions with specific names and then avoid the way we write the code as you saw here
That is one of the approaches that people take to deal with the Callback Hell problem
There are several other approaches that have been suggested links to a couple of articles in this regard are provided in the additional resources
But in this particular lecture I will concentrate on one particular approach that is used to deal with for the Callback Hell problem that is the use of promises
So we can use promises to tame the Callback Hell problem to quite an extent
We will look at how promises help us in this regard and in the exercise we will see how because the NODE MONGO DB driver already supports a proxy interface we can leverage that to rewrite our code to take advantage of promise support in the MONGO DB driver
Briefly summarizing what a promise is
A promise is a mechanism that supports asynchronous computation
So if you have amount of work that needs to be done the promise acts as a proxy for a value which is not known at the moment but the promise is given to you
But when the value becomes available it will be available in the future
So the promise represents a placeholder for that value
If the value results correctly then your promise results correctly and you can have a piece of code execute in order to handle the fact that the promise resolved correctly if not then you handle the error in that situation
So a promise will resolve either into resolve or the rejection of the promise
A pending promise might either resolve when the value is correctly obtained so in that case it will resolve or what we call as the fulfilling of the promise
So when the promise is resolved then you will have a piece of code that handles the fact that the promise has been resolved
If the promise is rejected you should also handle that situation the rejection of the promise correspondingly within your code
So that is the reason whenever you create a promise you only supply the resolve and the reject options from it
The resolve option is typically handled by the doctor then option for your promise
So why do we use promises? Promises are used because it addresses the callback hell problem to a large extent and promises can be changed
For example if you have one promise which in turn triggers a call to another one which will return a promise
The handling of the promise can be changed to the handle of the previous promise
So you can have a bunch of then calls that will handle the return of the value
Now we will see the use of this in the exercise that follows this lecture
To consume a promise you will register an appropriate callback function for when the consumer of a promise is notified either of the fulfillment or the rejection of the promise
So the callbacks are registered through the.then() to the promise
You will use the.catch() to catch the errors within the return promise
Now the.then() methods can be chained together as you will see in the exercise that follows
As an example you would normally handle a promise by chaining the.then() and the.catch() to the promise value.
We have just learned about Callback Hell and how promises can enable us to overcome this issue
We know that the node MongoDB driver natively supports promises
So if you do not specify a callback the calls to their functions will return promises
So we're going to update our application to make use of promises to avoid the callback hell issue that we just learned about in the previous lecture
Getting back to our application again taking one more look at the reason the callback hell has developed in our code
Note that here when we implemented the operations we have one operation and then inside the callback of that operation then we need to initiate the next operation and inside the callback of that operation we are initiating the next operation and so on
So you are ending up with this pyramid like structure here
One operation inside the callback of another and inside the callback
Now this code will pretty soon get unwieldy and complicated to understand
So that is why we want to transform this code using the promise support that Mongo DB Driver already provides for us so that we can instead use promises rather than using the callback functions as we did in this exercise
Of course I did the previous version just to illustrate to you how we can land up with callback hell and how we can use promises to overcome this issue
So before we update the index.js file let me go into the operations.jsfile and then we will update this first
So in here you'll notice that when we are calling this function here we are passing in the second parameter which is a callback function here
So because we're going to be using promises here
So I'm just going to delete that callback function and then since this call to the insert will anyway return promises I'm just going to return the promise from this function
So note how the code got simplified
Similarly for the second one I will simply remove this callback function and then return the promise that is being returned by this and then we'll handle that in the code in index.js
Similarly for the delete one also I am going to remove the callback and then return that crash and also for uptade
For update we're going to remove the callback that we have given here and then return the promise
So this way all these four functions are going to be returning the promise that is already returned by these calls to the MongoDB driver functions
Now once we have completed that let's go back to index.js
In index.js I'm going to again update this function here
So using promises will say MongoClient.connect(url) and then we will replace this by saying "then" and this receives only the db as their parameter
And inside here we'll handle the rest and also we can do notice that this particular function closes the "Then" here and the promise the second part to the promise we can handle the error
We can say consolelog
So we can use the catch of the promise also to catch the errors
So that way we have caught the errors
Now let's improve the code inside here
So inside here we are doing DB operation insert document and instead of calling this function here what I'm going to do is to turn this into the "then" here
So I'm going to close off this and say.then result
So inside those result we're going to print out the console log and then
So I'm going to close this off here and then we'll close the "then" here and then this will be attached to again a "then" here
So you see that I am chaining two "thens" one into the other here and then inside of us then we'll do a console log and then we'll do a return of the next operation
But then for this operation I am going to close off this and close this then and then this call back again now will be handled inside a "then" function here
So note how you have the first function and in the "then" we are calling the dboper find documents and that will return and this will return a promise
That promise will be handled by this then
So we are chaining two thens together and then again chaining one more "then" here
Let me reinvent the code here and then we will return this here and this again will close off and close that "then" and then this gets enclosed inside the next "then" and we will call the next function here "that db.dropCollection('Dishes' and close off "this then" and the next one here
We'll handle the "then" of the result here
Return dbclose and all these here can be now removed because they are no longer needed
And then finally if there is an error will catch the error this function
So I'm just going to copy this and then paste it here
That is it
With this change now your code is a lot more easier to handle here
So as you can see you have the MongoClient.connect which returns a promise and inside the handling of that promise they're calling these methods and one after another they are each returning the promise and then you're chaining them using the the
This chord structure is lot more easier to follow than what we had implemented earlier
So using promises we have literally turned it around and then avoided the callback hell that we saw in the earlier version of this application
So let's save the changes to both the index.jsn.operation.js and then take a look at this application
Again going to the terminal at the prompt type "npm start" and you will see that your application runs exactly as before it inserts the document finds the document updates the document and then finds the updated document and then closes the database of the act
So using promises we have restructured the code to be lot more easier and avoided the callback hell that we saw in the previous version of this application
With this we complete this exercise
In this exercise you have seen how we can make use of promises to avoid the callback hell
This is a good time for you to do a git commit with the message callback hell and promise.
In the previous lesson we learned about the MongoDB driver
That enables our node application to communicate with a MongoDB server and also store and retrieve documents from the MongoDB server
We also saw that the MongoDB driver provides us with many methods that enable us to create collections within a database add documents to the collections and then perform various operations on the documents within a collection
Now when the documents are stored in the database the MongoDB driver itself imposes no structure on the documents
If we need to have specific structure for the documents and enforce that structure then we need to make use of the Mongoose node module which enables us to define a schema and a structure for our documents that are stored in our MongoDB database and strictly enforces the structure
Let's look at more details in this lecture and the exercises that follow this lecture
As we have already learned MongoDB stores data in collections in a database
These collections consists of a collection of documents
The documents themselves stored in a MongoDB database have no specific structure imposed on the document
Any document can be stored in any collection
MongoDB relies on the developer to enforce the structure on the documents and gives the complete responsibility to the developer to make sure that documents of the correct structure are added and maintained in the various collections
Now it is very easy to violate this
So for example even though you might start out with the assumption that a particular connection will have documents of a certain structure you can easily insert documents that don't necessarily comply with the structure
If you are very particular that the structure of the documents in a collection always have a specified structure and always will have the specific set of fields then the MongoDB itself doesn't impose that neither does the node MongoDB driver that we have seen in the previous lesson
This is where we will need a more formal way of imposing structure on the documents that are stored in a collection in a MongoDB database
This is where the Mongoose node module comes to our help
The Mongoose node module imposes a standardized structure for the documents that are stored in a particular collection
So that is why we often hear people referring to this as the Mongoose ODM
The ODM itself is interpreted by some people to mean Object Data Model or sometimes referred to as Object Document Mapping or some people refer to it as ORM or Object Relational Mapping
Now when we talk about relational that applies a lot more to relational databases but then with SQL databases we needed explicitly the object to relational mapping to be put in between the database and our application itself
Because within the application we would be looking at objects but their storage in an SQL database will be in the form of records and so you need an explicit mapping
As we saw with the NoSQL database this was not explicitly required
But if you need to impose structure on your documents that are stored in a collection then the use of Mongoose to impose this structure is very very useful
The way Mongoose goes around imposing structure on the documents is through the use of schema
Schema defines the structure of their documents
Let's talk about that in a bit more detail
So what exactly is mongoose schema and what does it bring to the table? Mongoose schema implies a structure on the data that is stored in a document in your database
So it defines all the fields of your document and also specifies the types of the fields and also can provide us with additional features that can enable validation on these fields
So for example the various schema types that are supported in Mongoose include: String Number Date Buffer Boolean Mixed object ID and Array
In particular we will look at string number and a date and Boolean in the exercise that follows
We will look at some of the other ones in later exercises
In particular notice the use of the array schema type
So an array schema type would allow you to create an array of sub documents inside the document
I'll talk about that in a short while
Once you define a schema the schema is then used in Mongoose to create a model function and that is what enables you to define the structure for your documents in the database
Schemas themselves can have nesting
So which means that you can have sub document that are enclosed inside a document
The sub documents typically are accommodated either through specifying an additional schema and then defining one of the fields of the schema to be off the type of the other schema
Or you can even go with an array of another schema type within a second schema that you define
Let's look at an example to clarify some of these in more detail
This example will be from the exercise that you will do right after this lecture
Before I can talk about schemas and models in Mongoose let's understand why we would need that
If you have taken the previous angular or the ionic or the native script course you have seen that we represent various data that we use in our applications in the form of JSON strings
So in our application we define a collection called as dishes
In a dish collection each dish will contain a certain set of properties defined in the form of JSON string as you see in this example here
So the dishes is an array of dish type and each dish itself will contain a name an image a category a label and so on
Also inside the dish document itself you would have comments which are stored as an array of again  JSON documents which contain specific fields step
So each comment for example contains a rating comment author and a date field as you see in this example here
So you see that there is a clear structure to each document that defines a dish that is stored in our database
Multiple dishes obviously will be stored in the form of a collection in our database and could be grouped together and sent over as an array of dishes to our client application to be made use of
Now that we have understood how this is defined now how does this relate to the Mongoose schema and the model that we define in Mongoose? Now note the structure of a typical dish document here
So this could be easily mapped into a MongoDB document in a collection perhaps named the dishes collection
So we see that there is a clear structure to the document itself
Now how do we mirror this in a schema in our Mongoose application? As you will learn in the exercise we will see that we would define schemas in Mongoose
So the schema is defined as a Mongoose schema here
As an example a commentSchema is shown here
The commentSchema as you can see contains three different fields: the rating comment and the author field and also timestamps here
The timestamps allow you to have two different fields in the document: the created at field and the updated at field both of which are timestamps stored in the form of an ISO date string in the document
Now the rating itself would be an integer value
So in Mongoose terminology it will be stored as a number the type would be a number
You can even specify the minimum and the maximum value
You can also specify that this particular field is required so which means that every document of the comment type should contain a rating field
Similarly you can also define a comment field which is of the type string
So obviously a comment is nothing but a string which contains some information and this can also be defined as a required field meaning that every document should contain a comment and also an author field which is also of the type string
So you see that by defining this schema in this format
As we learned in the discussion a little bit earlier schema is defined by using the various types that we have in our Mongoose application
So in the schema again you see three different fields here rating comment and author here and each of which has a specific type given and then whether this is required or not
So thereby you are imposing a strict structure on the comment documents that are going to be storing in your application
Now that we have defined a comment schema we can then as you noticed from the example of the kind of data that we require in our application we have a dish document itself
The dish document contains various fields
Here in the exercise we will first introduce just two fields into the dish document the name and the description
In the next lesson we will introduce the remaining fields for the dishSchema
Now so the name as in this case is of the type string
We can also specify that this is a required field meaning that every document should contain the name field
We can also specify that the name field is unique meaning that no two documents can have exactly the same name value in the document
So that ensures that each document will have a unique name field in it and a description field which is again of the type string but also specified as required
Now as we saw in the example a dish document contains multiple comments enclosed inside the document
Now in Mongoose this is supported through the use of sub documents
So if you define a schema earlier so for example we have already defined a commentSchema here you can also define a field into another schema that you define and then specify that that field will be of the type of the previous schema that you have defined
So in this case the comments field I am defining it as an array so you see the use of an array type in your schema that you're defining here and then array of the commentSchema type
So this is an array of comments that will be included in each dish document
So thereby you can have more than one comment sub document enclosed inside a dish document
So defining the structure like this enables us to support the corresponding JSON string structure that we have defined for a dish document or that we have seen in the example earlier
Now once we define the schema to make use of this in our application we need to create a model from that schema that we have just defined
So within our application we will define a Mongoose model and specify that the model is off the type dishSchema in this example
Not only that you will also give a name to the model here
So when you give a name to the model here we are specifying the name as dish
Now when you use this dish model in our node application where we are making use of Mongoose then this will be transformed and mapped into a collection in my MongoDB database
The collection itself will be named as dishes
So Mongoose automatically knows that when you specify a name here it'll automatically construct the plural of that name and then give the collection the name which is the plural of the model name that you specify in this example here
So when I say dish here then Mongoose automatically will map this into the dishes collection in the MongoDB database
How does it know how to convert this singular name to a plural? Mongoose automatically has a built in mechanism that enables it to construct the plurals of standard English words
So if you say dish it will construct dishes
If you say leader it will construct the plural of it as leaders and so on
So this is already built into the Mongoose node module
So that is why when I specify this as a dish model type then Mongoose will construct the dishes collection in my MongoDB database and then that dishes collection will store the various documents of the dish type in there
Once we have created that typically when we declare models in our application we would store them in a sub folder named models just for convenience
You don't need to do that but just to organize your application we would normally store that in a folder named models
Then the schema and the model would be defined in a file like this as you see in the example here this called dishes.js and then this would be exported because this is a node module
This'll be exported from this file so that it can be included into the node application where we are going to make use of this schema and the model that we have just defined here
With this quick understanding of schema and model and its use in defining the structure for a document that we store in a MongoDB let's go back and understand a little more about what Mongoose provides for us
In addition Mongoose enables us to establish the connection with the MongoDB server
Mongoose internally make use of the MongoDB driver that we had used in the previous exercise
So Mongoose depends upon the MongoDB driver so which means that from your Mongoose based node application you can use all the methods that are already available from the MongoDB driver also if you choose to but Mongoose itself has its own collection of methods that we can make use of to interact with the MongoDB database as we will see in the exercise that follows
Let me briefly show you how we would establish a connection to the database and you will do this in the exercise that follows
So just like we declared the URL in case of the MongoDB node application in the earlier lesson we will still declare the URL for our application
Then we will use the Mongoose connect method and supply the URL for the Mongoose connect method and this will establish the connection to the database
With this quick understanding of Mongoose and what role Mongoose plays in supporting structured insertion storage and retrieval of documents from our MongoDB let's move on to the exercise where we will get some hands on experience using the Mongoose module.
Now that we have had a quick overview of Mongoose ODM and how Mongoose brings schemas to structure the documents that we store in our MongoDB let's look at how we make use of the Mongoose node module and then incorporate it into our node application
Then use Mongoose to communicate with our MongoDB server and then store and retrieve documents with structure information in the documents
To get started on this exercise go to a convenient location on your computer
So here I am in the Node JS folder where I have been storing all the examples from this course and then I'm going to create a new folder named node Mongoose
This is where we will create the node application using Mongoose next
In the terminal or the command window move to the node Mongoose folder and then initialize a node application there
So let me type npm init and then initialize the node application and then I would name the application as node Mongoose and the entry point is index.js git history keywords author and license and we'll say okay
Once your node package.json file is created open the project in the text editor of your choice
So here I have my project open in Visual Studio
Let me go into the package.json file and then add in the startup script and then we'll say start node index as usual whenever we start out with a new node application
Then going to the terminal or the command window let's install Mongoose
So at the prompt type npm install Mongoose save
Which at the moment is Mongoose 5.1.7
So these are the versions that I'm going to be using in this course
Then going to my application in the editor
Let me create a sub folder in the project called as Models
So this is where I'm going to be storing all the models for my application
In the models folder let me create a new file named dishes.js
So this is where I'm going to create the schema and the model for my dishes document that I'm going to store the dishes collection which stores the documents for each dishes
So right there let me first import Mongoose
So we'll require Mongoose in this file and then say const schema is Mongoose schema
Then we'll create the schema here
So we'll say const dishSchema new Schema
So this is where I define the schema for my dish
Inside this schema let me define the various values
So I'll say name which is the type String
So this is the Schema type and then this I would declare as required
So I'll say true
So every document will have the name as a required field there and then I will also declare this as unique meaning that no two documents should have the same name field in there
So that is the first field in my document
Then we will also include another field called as description
The description is of the type string and required true
Also we can have Mongoose automatically insert timestamps into our model
So right there we can just set up the flag time stamps: true
So this will automatically add the created at and updated at two timestamps into each document that is stored in our application and it'll automatically update these values
Whenever we update the document and the created at will be automatically initialized when the document is first creator of this time
After this we will say var Dishes
So given the schema now we going to construct the model from this schema
So we'll say Mongoose model and dish and this is going to be using the dish schema that we have just declared earlier
Then we will export this model from this file here
So we'll say module export dishes
So now we have constructed the Mongoose schema and the corresponding model and the model is now exported from here
So this can be imported in our application and used
So within our project folder let me create a new file named index.js
In the index.js file let me first require Mongoose and then after this we can say const Dishes require models dishes
Because we have already created the Dishes model in the models dishes file there and then we are requiring it here
Now to establish the connection to the Mongo server we'll say const URL mongodb
Localhost 27017 conFusion
So this database is the one that we will connect to from our application and then after that we can establish the connection by saying const connect Mongoose
Mongoose supports this connect method which takes the URL as the first parameter
So once we have established this then we simply say connect then
Note that since we are already using promises we can just say connect then and then this will take a function as the parameter and inside here we can now connect to the database
So now once this connection is established let me do a console log saying connected correctly to the server and here I can create a new Dish by saying var new Dish and then Dishes and inside here I can specify a document so I'm creating a new Dish of this kind and then so in here I will specify the two fields that are required
So I'll say name description and so this is how you would create a new Dish and then once we create a new Dish from the model we'll simply say new Dish save
The save method will cause this Dish value to be saved and then as you expect will return a promise and then in here we will get the Dish value as call back in there and thenI can simply log the Dish value here and then after that we'll say Dishes find and so we'll find all the Dishes and then say exec
The exec will ensure that this is executed and that it will return a promise and so that promise will be returned so that it can then chain the method to the remaining ones
So you see how I am using promises and then I am invoking the previous method so this one finds all the Dishes within my database in the Dishes collection and then makes it available to me
So when I get the Dishes then I can just console log the Dishes just to see what is returned and this obviously at this stage should return this one single Dish that I've inserted into my Dishes collection and then we will say return Dishes remove with an empty JavaScript object which will remove all the Dishes from the database and return mongoose connection close which closes the connection to the database
And catch any error at this point
So we'll use the catch and then console log
That's it
So what we are doing here is we're creating the new this Dish and then we are saving the Dish then we are finding all the Dishes from the collection
That's it
We are using promises here so we have chained all the dens in here
That's it
Let's save the changes and then see this application executing
Go into to the terminal at the prompt type npm start and you will see that my node application runs and then it shows first that it has created this particular Dish
Note in particular that these two fields updated at and created at these two timestamps have automatically been added into the Dish here and so you can see that the created at and updated at timestamps are exactly the same at the moment and then the ID is also automatically added in
In the next step we are printing out all the Dishes that have been retrieved and so you can see that this one single Dish is in the collection Dishes collection and that is what is printed out on the screen here
Let's now initialize the Git repository and then let's set up the got gitignore file so going to the editor then we create the.gitignore file and then add node modules to the gitignore file and save the changes and then going back to the prompt let me type git status and we see that we have these files that have not been checked in so we'll say git add and then git commit the message Mongoose Part One
With this we complete this exercise
In this exercise we have seen how easy it is to set up a node application with mongoose and connect to our MongoDB server and then interact with it
Now since mongoose builds upon the MongoDB server Mongoose can access all the various methods that are supported by the MongoDB driver also.
In this exercise we're going to continue working on the node Mongoose server that we developed in the previous exercise
We will do another variation of that
In addition we will also look at how Mongoose supports sub documents and this enables us to store a document inside a document for storing additional information
Let's look at that in the exercise next
Continuing with the example that we have been working on now in the index.js file now we'll see a new way of creating a dish and adding it into our application
So earlier we had done var newDish and dishes and define the dish
Now in this case we will use a new method called dishes create which takes as a parameter the newDish to create and then saves it in our application
So instead of doing this newDish save we can simply remove that and directly deal with the dishes create method here
So the dishes create method will take as a parameter a new document that needs to be stored in our database and then creates and adds the document to the database
Thereafter we can continue with the rest of the exercise
This minor modification will show that the same application runs exactly the same way as before
So with this change let me just change the indentation here so that the chaining of the then methods is very clear
So we first do a dishes create which will return a promise and then change to the then and then we will carry out the remaining steps on the created dish
Let's save the changes and then go and take a look at this version of our server
Going to the terminal once again running the application we see that it will create exactly the same as the previous variation of the server
So we are creating a new dish here and then inserting it into the database and thereafter we are retrieving that dish and then printing out on the screen
With this change this is a good time for us to do a git commit with the message Mongoose part two
So let's check the git status and then add the file to the repository and then do a git commit with the message Mongoose part two
Continuing with the exercise in the next step we're going to add in a sub document to the document and see how sub documents can be stored in our database
So going to dishes.js file I'm going to add in another schema into my dishes.js file called as comment Schema and then define this as new Schema
In this comment schema as you would have already expected we're going to use this to store comments about the dish
So the comments will contain a rating field which is of the type number and its minimum value is one maximum value is five and required is true
So you can see that when you use a field with the type number you can specify the boundaries for it if you choose to
Then the next field is a comment field which would be of the type string
So this stores a message and then required is true and then we'll also add another field called author which is of the type string and required is true
We will also add the timestamp field for this and set that to true
So for every comment that is added we will also store the corresponding timestamp
So now that we have declared a comment schema we can then go ahead and modify the dish schema to be able to store comments
So within the dishes schema we can add in comments which is an array of the type comment schema so which means that every dish object dish document can have multiple comments stored within an array inside the dish document
So this is the comment documents becomes sub documents inside a dish document
So we're storing all the comments about the dish inside the dish itself as an array of comment documents
So this is the usage of the sub document in Mongoose
After this let's go to the index.js file and then modify our index.js file
In here they create the dish just like before
Then after we create the dish then we console log the dish
Thereafter we will update the dish
So we'll say dishes find by ID and update
So we're going to modify the dish that we just inserted in the previous step
So we'll say "Find by ID and update." And we're going to supply
In this takes two parameters the first parameter is the dish._id
Now this dish._id of course refers to this dish that we have just inserted and then we're going to modify that same dish in the next step
So we'll say "Dish._id." And then within brackets we specify $set description updated test and new true
So this we are modifying the dish that we have just inserted by updating its description there
Now this has to be enclosed inside
This second flag that we are supplying here new colon equal to true means that once the update of the dish is complete then this will return the dish updated dish back to us
So that's the reason for using this flag here say new true
So this dish will be returned in the next step
And so we're going to take that dish and then print out that dish
So in the next step we're going to modify this and say "This then dish." And then we'll do a console log of dish
Then after this we're going to insert a comment into the dish
So we'll say "Dish.comments.push." Recall that the comments is a field inside the dish
So going back to the schema we see that this comments is an array of the commentSchema type
So which means that we can push an item into this array
So going back here we'll say "Dish comments push." And then we'll push a comment document into the dish here
So I will say "Dish comments push." And specify the fields here
So we'll say "Rating five comment and author." And so this will push this comment into the comment field of this specific dish
So now that we have modified the dish the next step that we're going to do is to let me close off this and then put that into it then there
I'm going to come back and fix that in a short while
So now that we have modified the dish we need to save the dish
So we'll say "Return dish safe." So in this step we are inserting a comment into the dish the dish that we have just created and updated and then we are saving that comment; and then this will return the dish
And when the dish is returned in the next callback I'm going to then say "Console log dish." And then after that we will say "Return." So with this we have modified our index.js file
Let's save the changes and look at this application
Going to the terminal let's run npm start and then see the resulting value here
So going back we see that in the first step we have created this dish here with the name and description as we have given earlier
And then once the dish is created in the second step we updated the dish and then printed out the updated version of the dish
So the updated version of the dish is printed out right there
And you can see that the description has been updated from the previous case but the id remains exactly the same as the dish that we created earlier
And the comments field as you can see here is an empty array and the smoked
In third step we push the comment into our dish here; and then so this particular comment that we added has been added into this comments array
So you can see that comment being enclosed here and this is the updated dish that has now been printed onto the screen here
So you can see that we have done several steps one after another with our dish
We first created the dish then we updated the dish then we inserted a comment into the dish which is a sub document inside the dish document; and then we printed out the result to you
With this we complete this exercise
In this exercise we have seen how we can first create a dish by using dishes create then we saw the use of sub documents: there we defined a schema within the dishes.js file and then use the comment schema that we defined and then defined the field in the dishes schema as an array of the commentSchema type
And then in the index.js file we were able to create a dish update the dish and also push a comment document into the dish and then save the changes here
With this we complete this exercise
This is a good time for you to do a Git Kermit with the message "Mongoose part three."
In this module in the very first lesson we learned how to build a full fledged REST API server using express
So we're able to service the GET PUT POST and DELETE requests coming to the various REST API end points
But the server itself was simply returning a simple message in response to these requests
In a real REST API server any incoming request will entail a corresponding operation to be performed on the back in the database perhaps to retrieve data to respond to a GET request or maybe to modify data that exists on the server in response to a PUT request
Now in the rest of this module we have studied about how we can interact from a node application with a MongoDB server be it using the MongoDB driver or using Mongoose
Now a full fledged REST API server that is able to handle the request end to end will be possible only when we combine the two together
That is an express based server that does all the business logic processing and at the same time will issue the database requests to the MongoDB using the node MongoDB driver or using Mongoose
So how do we combine the two together? So this is what we will look at in this particular lesson and the two exercises that we will do as part of this lesson
We now have learnt how to build a REST API server using Express and service the various requests coming to the REST API end points
We have also seen how we can interact with the database from our node application
Now given that you have a GET request coming into the server as an example to handle this GET request end to end a GET request coming from the client means that the client wants to retrieve data from the server and use that data
So a GET request coming into the server will have to be handled through the various processing done by for example the Express server and once the processing is done then Express server's business logic realizes that it needs to perform a query operation on the database
So this may initiate a query to the database in order to fetch a set of documents from the database and then the retrieved data will then be transformed into a reply message and then sent back to the server
So this end to end handling of the request and response involves two parts
One of course doing the business logic in the Express server and then doing the interaction with the database from the node application from Express server which is a node application using either MongoDB driver or Mongoose
We will be using Mongoose in the exercises
Similarly a POST request coming to the REST API end point on the server means that the POST request brings in some data in the body of the message
So this information needs to be processed in the Express server and the information that needs to be stored on the database should be retrieved from the body of the incoming POST request and then corresponding create request needs to be created or initiated from the Express server to the MongoDB database and in the create request the information that has been retrieved from the body of the POST request will be sent over to the database to create a new document in a specific collection on the database
And then the result of this operation will be sent back to the client in the reply message
So any operation that is done on a REST API end point whether it is a GET a PUT a POST or a DELETE operation as you see from these two examples will initiate a corresponding database operation behind the scenes
So having understood this interaction what we realize is that an HTTP request coming in to a REST API end point has to be mapped into a corresponding database operation
So every incoming request the GET PUT POST or DELETE means that a specific resource on the database may be accessed may be retrieved or a group of resources may be retrieved from the database and then sent back to the server or a resource may be modified in response to a PUT or a POST or even a DELETE request coming in to the REST API server
So it is up to the Express server logic the business logic implemented in the Express REST API server to handle this translation of the incoming request whether it is a GET PUT POST or DELETE request into the corresponding database operation
So let's look at an example of this in a little more detail
So coming to the combination of the Express router plus MongoDB plus Mongoose acting as the ODM in between the operations to be performed of the database have to be initiated inside the router that we built for each of the REST API end point
So within the router even the GET method the PUT or the POST method
The corresponding action to be performed on the database whether it is a GET request causing a dishes find method to be executed or a POST request causing a dishes create method to be executed will have to be done by our Express server resulting in the corresponding operation being initiated on the MongoDB database
So with this understanding of how the requests are translated into a corresponding database operations let's proceed on to the two exercises where we will look at handling the GET PUT POST and DELETE request coming to the /dishes/:dishId end points and also to modify specific comments that are in the sub documents enclosed inside the dish document.
As we have understood from the previous lecture in this lesson our goal in this lesson is to integrate the REST API server that we have already developed together with the access to the MongoDB database
So we will start with the REST API server that we built in the very first lesson in this module and then having learned how to interact from our node application to the MongoDB server using Mongoose we're going to be developing our REST API server further to integrate the entire path between the client request coming into the server all the way to the corresponding database operation to be performed and then constructing and sending back the reply to that client from our server site
To get started of course first go to the confusion server folder that we have already created in the very first exercise of this module in the REST API lesson and then in the confusion folder we have already built up the REST API server
Now what we would be doing is to borrow the models that we developed in the previous exercise the dishes.js file that we developed in the previous exercise copied over to the confusion server project and also install Bluebird Mongoose and another module called as Mongoose currency to our project
So going to our node JS folder we first go into the node Mongoose folder and we see that in the models sub folder of the node Mongoose folder we have the dishes.js file
I'm just going to copy the models folder and then go over to the confusion server folder and then simply pierce the models folder in there
So once we do that then the dishes.js file which contains the schema and the model for the dishes document are integrated into our REST API server
Of course in order to make use of that we need to install the Mongoose node module and a new node module called as Mongoose currency into our project
So going to the terminal in the confusion server project make sure that your terminal or the command window is in the confusion server project where you develop the REST API earlier and in this project let's install
So we'll do npm install Mongoose and then a new node module called as Mongoose currency
The Mongoose currency node module and seen in other Schema type to our Mongoose application so the Mongoose itself has certainly already built in Schema types
We have seen the use of the number the string and the boolean and the array
Now the Mongoose currency adds in support for currency
Now why would we need this currency support? So that Mongoose currency module adds a new type called as the currency type which enables us to store a currency value
Since our dish is going to contain a price that is why I'm going to be using the Mongoose currency module here
Now the exercise here we will illustrate the use of the Mongoose currency module you can read more details about the Mongoose currency node module also in the documentation of that a link to which is provided in the additional resources
So now that we have installed these node modules Mongoose and Mongoose currency let's go to our application and set it up to communicate with the MongoDB server
Now make sure that your MongoDB server is up and running
So here you see that my MongoDB server is running in another terminal tab on my computer
If you're running it on a Windows machine make sure it is running in another command Window of your Windows computer
Going to our application in the editor we will first start with the app.js file
Now in the app.js file this is where we built up our express application earlier
But now this extra suck negation is not connected to the back end MongoDB server
We're going to be making use of the Mongoose module in order to establish the connection with the server
So going in here I'm going to add in the require the Mongoose module here
So we'll say "Const Mongoose require Mongoose." And then also since we have copied over the models folder which contains the dishes file which declares the dishes schema and the model
So let me import the dishes
So we'll say "Require.slash models dishes." So once we have completed that now of course we need to establish the connection with the server
So set up URL mongodb// localhost7017/confusion just like we did with the Mongoose exercise and then we will say "Const connect Mongo's connect URL"
So this is exactly the same code that we used in the previous exercise
Then let's establish the connection
So we will say ''connect'' and then we'll say ''DB do it console log.'' Saying ''Connected correctly to the server.'' And we'll also handle the error here
We'll just simply do a console log of the error here that's it
That will establish the connection to the server from our app.js file
So once we have established the connection to the server then let's open the dishes.js file from our models
Now in the dishes.js file to make use of the node module that we have just installed
So we'll say ''Require Mongoose currency'' and say ''Load the type and Mongoose.'' So what this will do is to load this new currency type into Mongoose
Thereafter we can say const currency Mongoose types currency
That's it
So this new type the currency type is added into Mongoose and that will add in a new type called currency and then so I'm going to declare this constant currency as the Mongoose's types currency
So that I can make use of this in defining the schema in my application
Now in this case the common schema will remain exactly the same as before but the dish schema as you recall from the db.json file
When you look at the structure of a dish document you see that the dish document contains name and image which as you see here is a string a category a label a price which is a string type here
But we will declare this as a currency type a feature which as you expect is a Boolean variable and a description which is a string and then comments which is nothing but an array of comments type
Now so what we will now do is to extend the dish schema to support all these various properties or various fields in my json document
So we already have the name
So we already have the description in place
So we need to add in the next few in there we already have the comments the array of comments of the comment schema type there
So we will add in the next few
So the next one we will add in is the image type which would be of the type string and we'll say required true
So this adds the image type
The next one that I will add is category which is also the string type
The next one is label which is also this string type
Since all these are of the same type and required I'm just copying them in here
Then for the label I would say that this is not required but instead I can also specify a default value if I want
So I can specify a default value like that
Default value is an empty string
So if I don't specify required I can simply specify a default value here
Now in addition the next field that I'm going to introduce is the price field
The price field I will declare the type as currency
Recall that we had declared the currency type earlier here by first requiring the Mongoose currency module and then declaring the currency type
So that is how you would use the currency type in our application
So we'll say price type currency and required is true and then I can also specify the minimum value which would be zero
Then the next field is the featured field which would be of the type Boolean and the default value will be false
So if my document is missing that then the default value will be added into the document here
So notice that I have now expanded the dish schema by adding in the image type the category the label the price and the feature to match the structure of the dish document example that I just showed you earlier
So now my dishes schema is all ready to be used
So let's now start working on my router
So where is the router? You recall that the router that supports the REST API endpoints for the slash dishes REST API endpoint and slash dishes slash dish ID endpoint is in the dish router
So we will go to dish router.jsfile and then we will extend the dish router.js file
So in the dish router along with Express and bodyParser I'm going to now include Mongoose
So we'll say require Mongoose and then we will require dishes model
Where is the dishes model? It is in./models/dishes
So it is in there
So notice that we are in the router's folder so you need to go up one level and then go into the model's folder and then the dishes.js file is right there
So that is what we are importing here
So now I can update my dish router to be able to interact with the MongoDB server using Mongoose and we have already imported the dishes model into my dish router
So it is time for me to go and update all the methods in here
So for the dish router the slash which means that the slash dishes endpoint
I'm going to remove this all from here instead I'm going to explicitly declare all the various endpoints
To get post put and delete I will handle each one of them independently
So in the get method I'm going to cut that out and then in the get method what do I need to do? Recall that we had defined method from Mongoose which allows us to find all the dishes
So when you do a get operation on the slash dishes endpoint you're expecting all the dishes to be returned to the client in response to the get request
So I'm going to go to dishes and then perform the find operation
So now you see that from my Express server I am accessing my MongoDB
So will do a find and in the find I'm going to now handle the request
So I can say dishes find since that is going to return a promise then I can handle that inside here
So I'll say dish and so if the promise resolves correctly I'll get it in the then and so I'll say dish and then so we'll handle res status code is 200 and then we'll say res set header content type
Since we are going to be returning the value as a json so we'll set that to application json
Okay this will return an array of dishes
So I can simply say dishes and then we'll say res.json
So the res.json will take as an input in json string and then send it back over to my client
So when you call res.json and supply the value and then it will simply take the parameter that you give here and then send it back as a json response
It will put this dishes into the body of the reply message and then send it back to the server
Now we can handle the error here by saying next error
We can also do a catch error just for the sake of complete
I am just going to put both of these into place here so that both will be handled as such
So if an error is returned then that'll simply pass off the error to the overall error handler for my application and the let that worry about how to handle the error
So we're going to be sending it over to that
So you see how I am using the find operation and then performing the request here
Now for the post as you would have already expected I'm going to do dishes.create because we're going to be creating a new dish here
So recall that we are already seen the dishes create method usage earlier and remember that the body parser would have already parsed whatever is in the body of the message and loaded it onto the body property of the request
So I'm just going to take the request body and then parse it in as a parameter to my dishes.create method and handle the return value
So we'll say then and this would return a dish and we'll handle that in here
So we'll say if the dishes return correctly and if dishes posted correctly will say res
Okay let's do a console.log for our own usage
On the server side we'll do a console.log saying "Dish Created" dish here
Let's log that dish to the console and then we'll say these two rest status code
We'll just copy that code and then paste it in there and in this case we are returning the dish here
The dish that has come in as a parameter here and then let the client deal with that value on the client side whatever is returned in the dish
Now also they will add in this here and then the catch
So this is how we handle the post
For the PUT because PUT is not allowed so we're going to leave it as such
For DELETE we are going to be deleting all the dishes
So we'll say "Dishes.remove." This is essentially a dangerous operation
So you're removing all the dishes from the server and so we will say "Dishes.remove then" and the "then" will get some response
So we'll just say "resp here" and the way we would handle that response is simply to take that value and then return it to the client
So we'll say "Res.statusCode 200 content type application json" and then we'll simply send the response back to the client and we will handle the error just like we did earlier
That is the DELETE operation
So you see that now we are doing the GET POST PUT and the DELETE operation
Now we're going to be continuing the same with the /dishId end point
So in this case we are specifically motif getting a specific dish
We are going to be returning that specific dish value
So in the GET what we do is we will say "Dishes.findById
So the findById is a method that is available from mongo's as well as the MongoDB driver
So we'll say" req.params.dishId." Recall that we already know that the dish ID is present in the params property
You have already learned about this earlier
So I will say "findById(req.params.dishId)" and then and the else
So I'm just going to copy that then and else from right there and then come down to the dishRouter and then simply paste that in here
So we'll say " res.statusCode200 application json.res.jsondish and then the error handling
For the POST obviously we're not going to be handling the post for a /dishId endpoint
So we're going to be leaving it as such
For PUT we are going to be updating a specific dish which is identified by its dish ID
So this is where we will use dishes.findByIdAndUpdate
So this is the method that we're going to be using findbyIDAndUpdate and this takes as the first parameter req.params.dishId and the second value is the set and the update will be in the body of the message
So I'm just going to retrieve that from the req body and then also the other flag that I'm going to have
So will say "new: true" so that this findbyId method will return the updated dish as a json string in the reply
So that is what I'm going to be getting here and then when that value comes in I'm just going to take the dish and then simply return the dish to the client side
So I'll say res.jason(dish) and then we'll handle the error correspondingly
Finally for the DELETE
For the DELETE again the corresponding method that we are going to be using is the Mongo's method called findbyIdAndRemove
So you can see that we have this method called findbyIdAndRemove and this findbyIDandremove will take req.params.dishId because that's the dish that we are trying to remove
Then when this is deleted so just like we handled this here so I'm just going to copy this code from the Dishes.remove
Is the same thing that I'm going to be doing here also
So findbyIdAndRemove and whatever response I get I'm going to return it to my client
With this we have updated the dishRouter
Let's save all the changes that we have done so far and then we'll go and start up our server and then see what it does
So going to the terminal or the command window start the server
So I'll say "npm start" and the server is now up and running
We're going to be using the postman to communicate with this server
So let's go to postman and then perform certain operations
So here you see my postman up and running here
So let me do a GET operation on the localhost:3000/dishes
So when you do a GET operation as you see it'll return an empty string
My database is now empty so I don't have anything there
So I'm just going to be returned an empty string
Let's post a dish
So when you post a dish obviously in the body you will be enclosing a dish and the body will be set to be the application json type
Now to post a dish I have already given you the db.json file in the exercise resources
So just open the db.json file and then copy the very first dish from there and then we'll paste it in here and then post that dish
So let me go to the db.jason file
Let me copy the very first dish from here
So I am just going to copy the entire dish all the way up to there and then I'm going to post this dish
This contains a lot of the fields that we have here already
Let's post this dish to the server and see what happens
So coming back to the postman
In here in the form data in the body let me paste the dish into place
So we have the full details of the dish there
Let's POST this dish to the server
Then once the dish is posted to the server you see that the Postman has let me just shrink this and then you see at the bottom that this particular dish has been posted to the database to the MongoDB database by my server
So you see that the returned value here shows when the dish was inserted into that server
So you have the createdAt and updatedAt added there
You see that the remaining fields are all stored there
Note particularly how the price value is being stored there
This is how currency stores the price value
So when you get the return value you need to interpret this appropriately on your client side what that means
Note also that the ID has been added to my dish and for each comment itself because each of the comments is itself is a sub document
You'll have the updatedAt and createdAt added and the ID for each of the comments also added in there automatically by my database
There you go
So now this dish has been added to my database
Let's again perform the GET operation and obviously at this point the server should return that one particular dish that has been added in
So it will return an array of dishes here so as you can see it returns an array of dishes
Of course this array contains only one dish or that particular dish has been returned here
So far so good
So let's do a PUT on the dishes and see what happens
When you do a PUT obviously it says "PUT operation not supported on dishes" as we expect
Let's do a DELETE
Doing a DELETE operation it returns this response saying "N is equal to one" okay one meaning that it has deleted one dish
Let's now again perform a GET operation and then you would see that my dishes are empty as we expected
So you see that the GET PUT POST and DELETE operations are all working correctly
Now let me POST the dish again to the server because I want to have one dish in the server
So let me POST that dish and you would notice that the ID has now changed
So let me select that ID and then we will do a GET with the ID in place
When you do a GET with the ID in place you see that it returns that specific dish as you expect it
Let's go to the terminal and see what is being printed on the terminal or your command window
So going to the terminal or your command window you see that it is printing out all these things on the command window
So when we did the first GET operation it says GET /dishes
So this is again Morgan doing this work for you it is printing out tracing this information and it says dish created and then that particular dish information has been printed and then it says POST /dishes GET /dishes and then when you did a PUT it returned a 403 there and you again created dishes and so on
So you see that your server is actually doing all the work and these things are getting inserted into your MongoDB database as you expected
Now getting back to the Postman let's do a POST on the dishes
Now this is not supported on the server side so your server should say "POST operation is not supported on that particular endpoint" as you may expect it
Let's do a PUT operation
When you do a PUT operation what I am going to do in the PUT operation is that I'm going to be replacing the label in there
So in my body of the message
So recall that if you look at the DB.json file the label for that would be new and so I'm going to change that label to hot
Since this needs to be in Json so label also in quotes Json label hot and then let's do a PUT up on that particular endpoint
The PUT operation was successful and so you see that when the PUT operation was done then you would notice that the label now has changed from new to hot here and note in particular createdAt value and the updatedAt value
So notice that this record was created at this time point and was updated a little bit later
So the update was done by the PUT operation that I just performed on that particular dish
Let's delete the dish
This is allowed
So we'll delete the dish and then the dish will be deleted and the value will be returned
Now if you do a GET operation on the dishes endpointyou will see that this will return an empty
So you've just managed to delete the dish from our database
What I'm going to do is to perform a GET operation on a non existent dish and see what happens
When I perform a GET operation on non existent dish it returns null because that dish doesn't exist
So it returns a null value saying that the dish doesn't exist
Now let me perform a GET operation on a non ObjectID and see what happens
It returns as you see
Let me preview that
So it says "Cast to ObjectID failed for value here at path." So I'll be obviously this is not a valid ObjectID so I just managed to delete part of it and then perform the operation so it returns an error saying so you see there's 500 internal server error
The server was not able to handle this and then return this value here
So it says "No this is not allowed." So because that is not a valid ObjectID
So even errors are handled appropriately as you see here
So let me again do a GET operation on the dishes and your server is still running and it will return an empty value here
So we have seen how by modifying our REST API server to be able to interact with the MongoDB server
We now have a full fledged REST API server which is able to store and retrieve and perform various operations on the data that is stored on my MongoDB server
With this we complete this exercise
So in this exercise we have seen how we are able to interact with our REST API server and in turn with the MongoDB server and then we are leveraging the MongoDB server to store and retrieve data from the server
You're able to interact from our Express application with the MongoDB server using Mongoose
This is a good time for you to do a GIT commit with the message "Express REST API with Mongoose Part One."
The second part of this exercise deals with the various get put post and delete operations on sub documents inside the document
As we saw in the example for dishes we saw that the comments are included inside the dish itself as a sub document in the way we defined both the comment schema and the dish schema and then define the dish model by including the comment schema into the dish schema as an array of comments
And we saw in the previous exercise how the comments are enclosed inside an array in the form of a document array inside each dish document
So how do we make modifications to the comments themselves? How do we get all the list of comments for a dish? How do we modify a specific comment in the dish and so on? So this is what we will see about how to support them using the various get put post and delete operations on the dish dishes slash dish ID slash comments and the dishes slash dish ID slash comments slash comment ID REST API endpoints
To get started on this exercise again going back to the dish router they have already seen how we handle the slash endpoint and the slash dish ID endpoint
Now much of this work that we do here is already useful for us so what I'm going to do is to copy this code and then we will edit that code appropriately to handle the comments and the comment ID
So I'm going to copy this entire code that we have here both for the slash and the slash golden dish ID and then we will paste it right below here again
And then we will go in and modify each one of them
So we have seen that if you look back up the first one is handling the slash which will be mounted on the slash dishes endpoint
And the next one is handling the slash dish ID
So the third one should be handling slash dish ID slash comments
So going down here this third dish router route would be slash dish ID slash comments
And then the last one of course would be slash dish ID slash comments and then slash colon comment ID
So now that we have updated these routes here now the next step is to go in and fix the code in the get put post and delete operations here
So we will start off with the slash dish ID slash comments endpoint
So in case of the slash dish ID slash comments endpoint so we will do dishes find but instead of saying dishes find we will do dishes find by ID and so we will find the specific dish that we are looking for
So here we will look for that req params dish ID so we will first search for the dish and so this will return a specific dish
So when it returns that specific dish here then what they will check for inside here is that if dish not equal to null
It is quite possible that the dish doesn't exist so if we search for a specific dish with a dish ID that dish may not exist so we need to worry about handling that particular situation
So let's handle that part inside here and so if it is not null then that means that the dish exists
So I'm going to cut this out and then paste it in there
And then in this case since the dish is not null so we will return the status code and the set header and then this here we will be returning dish comments because we are asked to only return the comments for that particular dish so we'll say "Dishes find by ID then req parameters dish ID and then dish." And so we will return the dish comments here
Otherwise so this is the else part
So which means that the dish does not exist
So in this case we would construct an error here by saying new errors and then we'll say dish req params dish ID not found
So this particular dish was not found so obviously we won't be able to return the comments for the non existing dish
So in this case so we will create a new error object and then we will set the status in the error object to 404
Again this is 404 not found and then we will return next err
Now why do we do this? Because if you return this as an error as you'll recall this will be handled by your app.js file so in the app.js file right at the bottom here we have the error handler here
So when it comes in here this will set the rest or status to error dot status which we had set to 404 so that is what will be returned and then it will simply take that error and then render that error here
So that will take care of rendering the errors
So this will return the error message back to our client
That is what we are invoking here so if the dish does not exist we're just going to return that error here from the get operation
Now for post in case of post we are expecting that they would be returned a dish ID and then we will look for the dish and then we will take the set of comments from the body and then push it into the dish there
So we will say dishes again here we will have to do the find by id because we are looking for the specific dish here
So for the post we'll say dish find by ID then dish and so inside here if the dish exists then we will handle the dish appropriately
If not then we will have to send the error message
So let me copy this part from the get and then we will replace this here
So obviously if the dish does not exist then we're going to return this error here but if the dish exists in that case we will return the status code 200 set header
But before we pass back the value what I am going to do is to say dish comments so we are posting a new set of comments for the dish
So we'll say dish comments push req body
Because the body of the message contains all the comments that need to be pushed here and then we will say "Dish save." And so if the save returns successfully with the dish here so we will send the updated dish from here
So this part where we are constructing the status code we will do that inside here and then we will send the back the Res.json and the dish that we obtained here
So what we are doing is we are saving the dish here
We're first pushing the comments into the dish there the new set of comments into the dish here and then we are saving the updated dish here
Then after the save we're going to be returning the updated dish back to the user here
Then if there is an error then we will handle the error just like we have done here
If the dish doesn't exist of course we are going to be returning the error saying that the dish does not exist
So this is for the post
The PUT operation of course is not supported on dishes
So in this case we are trying to perform the PUT operation on the dishes req.params.dishId/comments
So this is not allowed
So that's what we are saying for the PUT operation
For the delete operation what we will do is first find the dish
So we'll say dish.findbyId
So delete means that we are removing all the comments from the dish not the dish itself but we are removing all the comments from the dish
So in this case what we would end up doing is as follows: so if the dish is not null recall that we need to handle it by saying then dish
If the dish is not null then we would remove all the comments from the dish
So I'm going to copy that code and then paste it in here and then we will edit this code then delete
We will see if dish is not null then they will return the dish here
So if dish is not not null the wat we would handle this is as follows
So we will have to go in and delete each of the comments
So we'll say for (var i = (dish.comments.length  1) i>= 0; i  )
So we are literally going in and removing each comment
So we'll say dish.comments.id(dish.comments[i]._id)
We'll say remove
So we are going to be removing each of the dishes one under each of the comments one by one
So this is what we will do to the comments
Then once we have removed all the comments for the dish then we will have to save the dish and then send back
So earlier also when we modify the dish this is what we did here
So I'm going to copy this part and then come in here and then say dish.save then we will return the dish here to indicate the updated dish being returned here
So this is how we will delete the comments
So here we are going in now there is no easy way of literally pulling out all the comments from the array when you have a sub document
So you have to go in and delete each sub document one by one
So that is what I am doing in this for loop here
So I'm saying for (var i=dish.comments.length)
So I'm looking at the array of comments and then starting from the last comment in that array all the way to the very first comment I'm going in and then deleting comment by comment here by using the remove operation on the subdocument
So the way we will access a subdocument is by saying dish and then comments is the field name and then I say id here
So this is how you access a subdocument and inside here you will specify the id of the subdocuments that you're trying to access
So this whole thing will give you access to the subdocument and then we call the remove method on the subdocument and so that subdocument will be removed from the array of subdocuments
Then after that after we have deleted all the comments I'll save the changes and that's it
So all my comments will be deleted from then dish
Now we will deal with the next end point which is dishIdcomments/:commentId
So in this case we will start out by first locating the dish and then after we locate the dish then we have to make sure that the dish exists and then deal with the dish
So I'm going to delete this part and then we'll say let's copy this part from the git that we had earlier because we need to be able to deal with the situation where either the dish doesn't exist or the dish exists but the comments don't exist or the dish itself does not exist
So there are three conditions that I need to test
So we'll say if (dish!= null && dish.comments.id (req.params.commentId)!= null so which means that the dish itself exists and also the comments exist in the dish only then we can send back a specific comment that has been asked for
So in that case we will say statusCode is 200 setHeader application json and then here we will send back dish.comments and we are sending back this particular comment
So that is the specific comment that we are sending max
So this will allow us to retrieve a specific comment from the set of comments
Now we'll say else if dish equal to null
So the dishes null then of course we will have to indicate that the dish doesn't exist and the last condition is if the comment itself is null
So in that case also I have to indicate that the comment itself doesn't exist that particular comment ID doesn't exist so in that case I will say new error comment req.params.commentId not found
So three conditions
First you have to make sure first that the dish exists and the dish comments exist if they do then i can send back the specific comment if not if the dish itself does not exist on the server side in the database then I will indicate that the dish does not exist but if the dish exists but the comment does not exist then I will send back the message saying the comment does not exist
So notice that they have to handle all the possible conditions here for the GET
For the POST of course the post operation is not supported on this endpoint so we'll say comments slash req.params.commentId
So the POST operation is not supported on this comment Id
Now what about PUT? PUT is a more interesting case here
So again even for the put I to have to handle all these possible conditions so I am going to look at this and say okay for this let me copy this whole code because we have to handle all these possibilities and then I'll tell you exactly how we handle the PUT case here
So in case of PUT first of course we need to locate the carnage
So they'll say dishes find by Id req param Id then if the dish exists and the comment itself exists then I know that I can update the comment
Otherwise these two conditions obviously have to be taken care of that comment does not exist or the dish does not exist
These two are already handled by that case
Now here is the special situation that we have
Soif the dish exists and the specific comment that I am looking for also exists then what I know is that in the body of the message the update for the comment is specified
So I need to update that
So somewhere here I do modifications I do a dish save here so I am going to go in and copy a little bit of this code from here of course this is not the right thing but I just need a part of the code from there so I will come into the PUT
Let me paste it into place here and then I'll tell you exactly how they are going to handle this
Because I need the dish save part
So how do we handle the update to a specific comment? So for the update to a specific comment what do we know is that this comment needs to be updated so we know that the dish exists and the comment itself exists
I want to update the fields of the current
Now if a comment already exists then I don't want to allow the user to change the author of the comment the author should retained
The only two fields that I would allow the user update is the rating
So within the body of the incoming PUT message I can either include the updated rating or the updated comment
These are the only two things that I will allow the user to change
So if the if the rating property ies indirect body to call that the body will contain the update that we are trying to do so in this case we will say dish
So we'll say dish comments so let me just copy this part
Dish comment comment Id
Now this is a simple way of handling this issue here
Because there is no specific way of updating a specific comment which is in a sub document there is no specific method for doing this
So this is the workaround that I found that seems to work for us so we'll say dish comments req parameter comment Id rating equal to req body.rating
So I will update the rating
Similarly if the comment exists there then I will say req comment Id comment req body comment
So that is how I'm going to be updating the rating and the comment and I once say about updated the rating and the comment and they will save the dish and then once I save the dish then I will send back the reply
So note that this is the only way that I found which is easy enough to update a embedded sub document inside a document of Mongoose
There is no explicit way that Mongoose supports for updating an embedded document
So this is the workaround that I found that enables us to carry out this operation
Now for the delete operation
For the delete operation we are deleting only a specific  Comment so I will take this information from the deleter for all the comments and instead of deleting all the comments I'm only going to be deleting a specific comment
So let me copy that over from the delete
Let me paste it in here and then we will update this
So if I am deleting a specific comment so I'll first find the dish
If the dish is not null recall that in this situation I have to handle both the dish not being null and also the comment not being null
So I'll say if dish not equal to null and dish comments id parameter not equal to null then I know that I have a specific comment that I want to delete
I'm not deleting all the comments I am deleting only a specific comment here
So I'll say dish comments id and then I am deleting the specific comment here which is req.params.commentId and remove that particular comment and then I will save the updated dish and then move on with that
Now the else part I need to handle both the situations
So let me copy this part else if dish not equal to null and so on and then replace this here
So if the dish is null then I will send back the error saying the dish doesn't exist
If the comment is null then I'll send back the error saying comment doesn't exist
So that is it this is the update that I'm doing here
For deleting a specific comment I will first ensure that the dish and the comment exist then I will delete the specific comment and then I will save the changes to the dish and then proceed on with handling the rest of the cases that's it
Let's save the changes and then look at how this works
Going to the terminal I see MongoDB server is not up and running so let's start there
Make sure of course that the MongoDB server is up and running let's also start our express server
Once your express server is up and running what we will do is we are now looking specifically at the comments and then performing operations on the comments
So let's go to the Postman and then check out what we have in the database and then try to modify the comments
So here I am in Postman so let me first get the dishes and now I see that the dishes are all empty
So let me post a dish to list of dishes so let me post one dish
Recall that we have this dish her so in my Postman I had already done that for the previous exercise
I'm just going to select that and then post that dish and then you see that that particular dish has been posted here down below here
You can see that the dish has been created right there
Let me now copy that particular dish id and then I'm going to now get that dish here
So you see that that particular dish exists here
First let's get all the comments
So if I do a get on the comments you notice that all the comments for that particular dish have been returned
We can do the post and the delete also
Let's do a put on that and obviously you can't do a put on back so you notice that the put operation doesn't work on that
Let's post a new comment
So to post a new comment we'll go into the body and then let me cut out all these and then we'll edit one of the comments and then try to post that comment
So we'll say rating three and then we'll say test comment test user
Let's post this comment
When you post this comment you see that the update dish has been returned here and you see that within this dish you see that the new comment has been included in there
So let's copy this whole thing
Now we will try to get that particular comment that we have just inserted
For that particular comment this is the id of that comment
So let me copy the id for that specific comment
Going back to Postman let me try to retrieve that specific comment by doing a get operation
There you see that that particular comment has been retrieved here
Now if you're try to do a post on thatthat will not work so obviously you see that the post operation is not allowed on that
Let's do a put operation on that particular comment
So if I were to put operation in the body I'm going to say updated test comment
So I'm going to update the comment field of that comment
If you're saying to put on that you will see that for the specific comment the comment has now been updated to reflect the updated test comment
So you see that the put operation on the comments field also works correctly
Let's delete that comment so I can delete the comment and then when I delete the comment you'll see that that comment has disappeared from the list of comments
So you see that the delete operation also works
Let's delete all the comments
So I'm going to go in and delete all the comments
Then you see that all the comments have been deleted and so you see that the comments area is now empty
So now you can see them all the get put post and delete operations on the dishes/dishId/ comments and the dishes/dishId/comments/commentId REST API endpoints all work as expected
So with this we complete this exercise
So in this exercise we have completed the implementation of the slash dishes REST API endpoint and supported all the way up to allowing us to manipulate a single dish the collection of dishes a single comment and also the collection of comments
This is a good time for you to do a git commit with the message express REST API with Mongoose part two.
 The Express REST API server that
we implemented in the previous module allows any user to perform any of
the GET or POST or DELETE operations
There is no control on who
can perform this operation
So which means that if you run a server like that
then anybody can come into your server and start manipulating the information
that is present within your database
This is obviously a dangerous situation
The way that server should
be implemented is that you need to have some
kind of restriction on which kinds of users will be allowed
to perform which kinds of operations
So maybe you would allow and an authorized user only to
perform GET operations
So for example if you want a guest
to be able to see information about the dishes in your restaurant or
the menu of your restaurant and so on that is perfectly acceptable
But you may allow only
an administrator to go in and modify the information about the dish or
to delete a dish from the menu
And also update an existing dish
in the menu or a promotion or the information about
the leaders in your server side
Now you could also have another group
of users which will be registered users who may be allowed to save some of
their dishes as their favorite dishes and only they would be able to manipulate
the list of their favorite dishes
So that is another level
of authorization or authentication that you need to perform
So you have different grades of users
and also depending on what kind of operations
they would be allowed to perform
So all this means is that you need
some kind of security to be built into your server side
We'll look at how we can
authenticate users and then decide what kind
of user this client is
And then depending on
the type of the user you can allow the user to perform
certain kinds of operations
We will start with the basic
understanding of this what we call as Basic Authentication in a server side for a client and then build upon that
throughout the rest of this module
And then at the end of this module
we will end up with a mechanism thereby allowing users
to register themselves
And registered users can
perform certain operations that an unregistered user cannot
and so on
So we'll impose various
kinds of access controls for various operations on the server side
based upon the kind of user
So that sets you the perspective or rather the idea of what you
will encounter in this module
Let's start with basic authentication the very basic mechanism that will
enable us to authenticate users
Basic authentication in HTTP
is a very simple mechanism which will ask the user for
a user name and password to be submitted with a request
And there is a specific structure on how this information will be sent
from the client to the server side
So this is a matter the basic access
authentication which HTTP supports is a matter that will enable a server
to challenge a client and ask for the username and
password to be submitted by the client
So the server can challenge the client
to authenticate itself by typing in this information
The client needs to send the username and password in response to
the challenge from the server side
So every request message
originating from a client should include the encoded
form of the username and password in the request header that
goes from the client to the server side
So when the server receives the request the server will extract this information
from the client's request header
And then use that for
authenticating the client before allowing access to the various
operations on the server side
So how does this authentication work? If a client sends a request to the server
and this client request does not include the
authorization formation then the server will challenge the client they're asking
for the client to submit this information
The server challenges
the client by including a header into the reply message coming in
The header with the type
as WWW Authenticate and then the second part where it
specifies the type is where it will specify what kind of authentication
the client needs to submit
And we will start with the understanding
of basic authentication here
And also notice that the reply
message will contain a 401 error code which is unauthorized
which stands for unauthorized
So when the reply comes back from
the server side then the client in response to this reply coming in the
client will have to send their request including a specific header field in the
request message of the type authorization
And this authorization header field
will contain some information in there
For a basic authentication
this information would be in the form of as the first word here will be Basic
And then followed by a space here and
followed by a Base64 encoded string here
This Base64 encoded string
encodes the username and password in a particular format and
then includes that in the header
Now you're saying if you send
out a request message like this including this in the header
then anybody in the middle
So if you know anything about security and how man in the middle attacks
can be launched then obviously this can be retrieved by
an intruder in between and then can be used to
fake the real client
Again we are not getting into
that question at the moment
When I talk about HTTPS
in the next module I will come back to address that
issue in a bit more detail
But for the moment the information
in the header will be sent over without being encrypted in
the header at this moment
Now one other reason why I'm doing this
is that so that we can actually look at the header directly and then see this
information in the header itself
So when the client sends this request
then the server will extract the information from this authorization
header in the request header
And then use this information in
order to verify whether this is an authorized a client request or not
Now of course your next question would be what exactly does this
authorization header contain? The authorization header itself
is constructed as follows
If you have a username and
a password these are the two pieces of information that you
will use to authenticate a client
So the username and password will be
concatenated into a single string by saying username and a colon
and the password itself
So the username string colon and password will be concatenated
together into an entire string here
This resulting string that we get here
is that encoded using Base64 encode
If you know about how encoding
is done basics for encoding convert that into an ASCII header
like as shown in this example here so this is nothing but
a string of ASCII headers
Now if you don't know much about basic
stiff encoding don't worry about it it doesn't impact your understanding
of what is going on here anyway
So this Basic64 encoded strings so this particular information is
encoded into a string like this and then enclosed in the request header
going from the client to the server
The request header itself is
of the type authorization and then followed by the actual
value here which says Basic and a space here and
the Base64 encoded string here
So when this is received by our sever
the server will extract this information and then from here it'll extract
the username and password and then verify whether that matches an
authorized user or not on the server side
To help you better understand how we
actually organize the express application and how the authentication itself is
carried out as we have learned earlier express applications themselves
are organized in a set of middleware
And the way the express application
works is that the middleware are applied to the request and
the response message in the order in which it is
declared in my express application
So if you have a express.use and then you have the first one saying
a static server then after that you have another middleware then after
that you have another middleware
The sequence in which they are declared
in the express servers app.js file for example is the exact sequence in
which the middleware will be applied
So an incoming request from the
server side as you recall in your express application the incoming request
is treated as a request object
The response object is what
the express server constructs and then the next is allows you to
go on to the next middleware that you're going to be applying
and so on
So an incoming request like this when it
comes in the first middleware is applied
And then once that middleware has
transformed both the request and the response it moves on to the next
middleware which is then applied to it
So for example
we saw that we applied Morgan first then we applied body
parser to the middleware
So they must have already transformed
the request and the response objects
And then after that we can include an
authentication middleware in place there
The authentication middleware is
going to authenticate the request
Now so if you are using basic
authentication do your request must contain in the header the
authorization header in place in there
So the authorization header will be
extracted by the authentication middleware and then checked to see if
the user is authorized
And if the authentication middleware
detects that you are an authorized user then you'll be allowed to proceed
forward to the next set of middleware that follows
the authentication step
And your records will be processed
by the subsequent middleware
But other hand if your authentication middleware decides
that you are not an authorized user then the authentication middleware will
take you along a different path off
And then generate an error
and then send back an appropriate error reply
to that client side and will be redirected to the error handler
So this redirection to the error
handler will be done by calling Next with the error as the parameter
to that Next here
So the Next is exactly this Next that we
see in the request resource Next here
And so that will take you all
the way down to the error handler which will handle error and then send back
the error message back to the client side indicating the failure
of the authentication
So this is how your typical
basic authorization or basic authentication works in
your server side application
Having understood this
let's move on to the exercise where we will implement the basic
authentication in our application and see how it authenticates users
Now that we have understood the need for
basic authentication in our Express application let's proceed to
the exercise where we will add basic authentication to the ConFusion server
that we have been developing so far the Express REST API server
We will along the way learn how we can use basic
authentication within our server
And then in subsequent exercises
we will expand upon this idea further to add a full fledged authentication
service for our Express REST API server
In this exercise
we will go to the ConFusion server what we have been working on so far
So you must have completed the
implementation of the second assignment by now where you would have developed
the promotions and the leaders model
And also updated the routes for
the leader router and the promo router in your
ConFusion server application
So within this code
let's go to app.js and then add in the basic
authentication into app.js
So in app.js as we have
understood about the way the middle way it works
in Express application
So we start out here in the app.js by importing all the various
node modules here
And then after that we start out here
by first saying app.use logger dev
So all these are going to be
applied to our application
And then
this call here app.use(express.static) is what enables us to serve static
data from the public folder
Now they want to do
authentication right before we allow the client to be able to
fetch data from our server
So right there we will go in and
add an authentication badge
So you notice that everything
that comes after this all the the middleware that is mounted and
comes after this particular point
We'll have to go through
the authorization phase before that middleware can be access
So right there
I'm going to add in app.use and then adding a function called auth
which I am going to implement right now
So by doing this
what we are specifying is the default the client can access any of these either their static resources in the
public folder or any of the resources dishes promotions or leaders or
even users as we will see later on
The client has to be first authorized
So right there we will add in the auth
So let me add in the function
here called auth right there
And then immediately use
it within our Express application as the middleware there
So this function
auth will take in three parameters the request object the resource object
and the next object yeah
So within this function let me first just to know what is contained
in the request header
Let me just log the request headers
right there just to demonstrate to you because once you add
the authorization header then we want to be able
to see it right there
So we will first do a console log just to see what is coming
in from the client side
Then let me get their authorization header by saying req.headers .authorization
So this is where we'll get hold of
the authorization header that is added in by our client side
If it is not there obviously
then we need to act accordingly
So if The authHeader is null which means that there is no
authentication header in our incoming request then obviously our client
did not include the username and password into the authentication header
So we need to challenge our client
to supply this information
So if the authorization header is null
then we'll see var err new error so we will not allow our client request
to go further beyond this point
So we'll say you are not authenticated and then we will challenge client there
So we'll say res.setHeader so we are going to be setting the header in the response message
saying WWW Authenticate and from the lecture earlier you'll see why we are putting this into the response header
And then we will say err status.401
401 is unauthorized access
And then we will simply generate
our call next with the header
So that means that it's going to skip over
all this and go to the error handler where the error handler will
construct the reply message and send back to my client there
So that be if the client has not
included the authentication header or the authorization header
then I'm going to challenge the client to ask it to supply me
the authorization header there
So if not then I know that
the authorization header exists
So beyond this point
we will say var auth and I'm going to extract
the authorization header
And then since the authHeader is a string I'm going to split that value and this authorization header
I'm going to split the value
So as you can see the buffer
enables you to split the value and then we also give the encoding of
the buffer which is Base64 encoding here
So we will convert that to a buffer
by splitting that into two parts using the space as the splitting part
So when you looked at the authorization
header you saw why the space separates the value saying basic
and then it gives you the rest of the Base64 encoded string which
contains the username and password
And from that we want to extract
the username and password
So we're going to split that value and
then we're only going to consider So when you split the string by using this
it will split that into an array
And the first element of
the array contains Basic
The second element of the array is
where this base64 encoded string exist
So that's why we are only looking at
the second element of this array
So this splitting will cause the string
to split into an array of two items
So we could we are picking up
the base64 encoded string from that
And then we into this Buffer and then
we're going to convert that to string
And then again split the string
one more time because the string itself will contain the username and
password separated by a colon
So I'm going to split
it using the colon as the splitting point for this string here
So notice that I am loading two
splits here one on the space and the second one using the colon which
separates the username and password
So at the end of this variable auth
should be an array containing two items the username and the password which
is extracted from the base64 string
So at this point
what I am going to do is just for your clarity I'm going to simply say var username = auth[0] and then var password = auth[1]
So now I've extracted the username and
password from my authorization header
Now I'm going to use a default value for
the username and password in this implementation
Later on we will see that we can allow
the users to create their own username and password
But for the moment I'm just going to use The encoded username and
password as admin
And The password will be just password
For this basic exercise we're going to be using this as
the default username and password
If the username that I obtain is admin and
the password is the string password
Then I am all fine to allow the client request will be passed through to
the next middleware so I will say next
So when I say next
this means that from the auth their request will passed on
the next set of middleware here and then Express will try to match
the specific request to were specific middleware which
will service that request
So this is where we will
allow it to pass through
If not that means that the username and password did not match the request the default username and
password that I am setting up
So that means that there is an error
So in this case
I'm going to again cause an error here so we'll say else Error
So we'll again generate an error and
then challenge the client to send in the correct authorization information
the username and password here
So that's it
This little bit of middleware that
we have just implemented here authorization middleware that
we have just implemented here
Is sufficient enough to implement basic
authentication within out application
So having made these changes let's save the changes and then we'll
see how this actually works in practice
Let's save the changes
And then we'll go and start our server
Now going to the terminal of course make sure that you're MongoDB
server is up and running
Otherwise your Express
server will not start up
So I have the prompt type npm start and then your Express server will be up and
running
Now open in incognito
window in your browser
The reason why I am asking you to use an
incognito window is that when you type in the username and password then
it will be cached by your browser
So if you use an incognito window
if you restart the browser..
Then the cache will be
cleared automatically so this information
will not be remembered
Now what happens if you type in the
username and password it will be cached so subsequently when you try to access
the server the cached information will be automatically sent in
the request that you generate
So that is why it is important to use an incognito window just to show you
that the basic authentication works
So in your browser address bar let's type
localhost:3000 and see what happens
So when you type localhost:3000 you
immediately see that your browser pops up this dialogue on top asking you to
type in the username and password
If you don't type it let me type in some
random username and then see what happens
So if I type in a random username and
password then you see that the request is rejected
I'm not allowed to access the server and then if the server will again say
that the client is not authorized
And so it will come back and challenge
us again for the correct authentication
So let me type in
the current authentication
So let me type in admin and
the password as password
And then log in and
you will see that now the Express application will allow you to go in and
access the default value which in this case is the Index.html
file from that static public folder
Now the same thing if you're
trying to access localhost:dishes without the authorization
then it wont work
And I'll demonstrate that to
you using postman in a minute
Now having seen how the authentication
works let's go and look at what happened on
the console on our server site
Going to the console on our server site
you see that a whole bunch of information has been printed out here so as you saw we were logging out
the request headers here
So this is the first request that
came in with the request header
And here you see that there is no
authorization header in the request
And so your server rejected that with a
401 asking our client to authorize itself
The second time also since we didn't
type in the correct authorization that server rejected
Of course you now notice that in the
header right there the authorization's actually included there and you see
the way the authorization is included
It says Basic separated by a space and separated by the 64 bit Encoded string
which contains the username and password
And then we see that the server rejected this because the authorization
was wrong at that point
Now later on we typed in
the correct username and password
So right there in the third request that
came in we typed the correct username and password
And so that is why you see that the
request header contains the authorization and this string use the correct
encoding of the username and password
How do I know that? Well I've cross checked and know that that is the basic foreign encoded
version of the string there
We will also see that from
our postman image or what
Now then
you see that the request was accepted and it returned the value correctly
And then of course subsequently the
client requested for a favicon the icon
And since we don't have the favicon in our
server side it replies with the 404 and of course your favorite icon is
not displayed in the address bar
So that's fine but note in particular
Those particular requested came in where the correct authorization
header was included
And so it was successful at the time
Let's try and see how we could
do the same thing with postmap
So here I have my postmap window open
And so
in my Postman window I'm going to type in a get to localhost: to my server
and then send the request and you will immediately notice that it
challenges saying 401 unauthorized
So this is the reply message
from the server side so notice what it saves 401 Unauthorized
And it says the response must include
a WWW Authenticate header field
And this will be challenging the client
to send in the authorization information the username and password
So previewing this we see that
the sentence you are not authenticated and then the code 401 here
Now looking at the headers
of the reply message
When you look at the header of the reply
message you can see in particular this header included there
which is www.authenticatebasic
Now how do we do authentication or
authorization in post? So this is where they would go to
this right below this box here you will see this authorization here
And when you click on the authorization
right now it says NO AUTH.
Let's use the basic authentication
So when I say basic authentication
it will give me these two fields here where I
can type in the username and password
Let me type in the correct username and
password
So I will say username admin
password is password P A S S W O R D
So you can see that that's exactly
the password that we have here
So once you type in the username and
password they'll say Update Request
So when I click on Update Request you
would see that immediately in the header you will see that there is this field here that has
been added here saying authorization
And then you will see what this
second part the value you can take
It says basic and a space and
then this particular string
So if you check this particular
string here this will be the exact string that you'll see in the header
of the successful request message
Notice what this string says
It say YWR something and
then ends with a Q equal to
Going to our terminal
you see that the successful request actually contained
exactly that string here
It says YWR and
then ending with Q equal to there
So by typing in the information into
the authorization and then clicking on the update request this information is
added into the authorization headers
So now this is a get request I don't need the content type there
because it doesn't contain any body
So now that the authorization
has been included let's send the request now correctly and
then you will see that the reply coming in from the server site
will contain the index file as you expect
Now let me delete the authorization
Now this is the reason why Postmap helps
me to check for these things a lot more easily I can delete the authorization and
then send the request
And it will still contain
this authorization because I typed this into
the authorization field
So let me clear the authorization from
there and then send the request here
And then it says you
are not authenticated
Similarly if I send
the request to the dishes
Previously this worked fine but now you see that we are prevented from
accessing the /dishes endpoint also
And the same thing with all
the other rest APR endpoints also
You will not be allowed to access because
the authorization middleware comes before you get access to any of these endpoints in the list of middleware for
your express server
So now if I now include the authorization And then update my request and
then send the request to the server then the server will respond
Now obviously at this moment
my the database is empty so it is replying with an empty array there
But now the request went
through successfully and I'm able to retrieve the information
from the server sock
So this is a quick demonstration of basic authorization in our express
rest APR application
With this we complete this exercise
This is a good time for you to do a get comment with
the message of basic authentication
In the previous lesson
we learned about basic authentication
We saw that in basic authentication
the client will have to explicitly keep adding in the authorization field
containing the username and password for every request that
the client sends to the server side
Now that is perfectly fine for
simple authentication
Cookies are yet another mechanism that
is provided that enables your server to be able to expect the client to store
some information on the client side and include that information explicitly
in each outgoing request
So instead of including your
base 64 encoded username and password like we did in the basic
authentication using cookies your server may set up an explicit
piece of information on the client side which then will be included in each
outgoing request from the client side
Now expanding this further if your server
wants to track information about your client then the server may set up
explicitly a session tracking mechanism
Now cookies are small and
can't store a lot of information in there and this of course can not be
included in the outgoing request
Cookies can include some basic information in the header of the outgoing
request from the client
Now if we want a lot more of
information to be tracked about a client on the server side then
express sessions enable us to do that
Let's study more about cookies and Express sessions in a bit more
detail in this lesson and also explore them further in
the exercises that follow this lecture
So what are HTTP cookies? HTTP cookies as I mentioned
are small piece of data that is sent from a web server and
is stored on the client side
Now almost all browsers
have the ability to support the storing of cookies on the client side
and automatically including them in the request when the request
is sent to a specific server
So each subsequent request from the client side will include a new header in there with the cookie in the request header
Now obviously if you have seen the
popular press have gotten a bad reputation there this is of course
not completely undeserved
But it is blown way out of proportion
than what is really the truth
So take anything that you read in
popular press about cookies and their bad reputation with a grain of salt
Cookies are very useful for
doing a lot of interesting things
And we can ensure that cookies
can have sufficient integrity built into them so that they cannot
be manipulated by anybody in between
Now how does this cookie setting
inclusion in the outgoing request work? When a client sends a request
to the server site if the client is authenticated
on the server site
For example
using the basic authentication then the server may in return
set up a cookie
Now to set up a cookie on the client's
site the server will include in the response message a header
with the sent cookie header and the actual cookie in the header
Now when the client receives the response
message from the server containing the Set Cookie header then it'll set
up the cookie on the client side
Such that each subsequent request
going from the client side will explicitly include a header
field called as cookie and actual header that contains as the value the cookie information that has been sent
by the server in the response message
So each subsequent request message
will carry this cookie in the header
Thereby when the server receives this
request message it is able to examine the cookie and
surmise who this request is coming from
So it is able to recognize the client
by looking at the cookie information
So this is where cookies
prove very useful in being able to send
authorization information
So in serving including username and
password as part of the basic authentication header in
every ongoing request
The first time you authenticate yourself
you send your username and password and the server sets up
the cookie on your side
Subsequently you only need to include
the cookie in the outgoing request
Now cookies also can have an expiry
date associated with them
So thereby at that point
the cookie will be deemed as expired and will no longer be valid
So that is one way of
controlling the duration for which an authorization is valid
Coming to Express itself
how does Express support cookies? Now as we understand
Express uses a lot of middleware
This is where one of the middlewares
that comes in called the cookie parser comes to our app at eight
The cookie parser allows the server to
set up a cookie in the response header
So this is done by using res.cookie and
the name and certain values and the options as
we will see in the exercise later
And so cookies when they are sent from
the client side included in that request message are parsed on the Express
server side using the cookie parser
The cookie parser middleware which when installed will enable
you to parse the incoming cookies
And then these incoming
cookies will be added into the request as a header and
can be examined on the server side
Now in order to protect
the authenticity of the cookie the cookies themselves can
be signed by the server
Now when the server signs a cookie
the server uses a secret key which is only known to the server side
Now if you know anything about
computer security and cryptography and encryption then you understand
what signing and secret keys and public keys and all these things mean
If you don't just suffice it
to say that a secret key is a specific string that only the server
knows and nobody else knows
So when a server encrypts a cookie it
will use a secret key as a signature and create what is called as a key hash
message authentication code
And includes this in that cookie that is
sent from the server to the client side
This HMAC that is created on
the server side can only be done by that specific server
knowing that secret key
Now since the server is
a protected resource so only the server will know the secret
key and so it is very easy to verify when a signed cookie is sent from
the client side to the server side
So when the signed cookie is sent from
the client side to the server side the cookie will be set up
on the client side and then all subsequent requests will include
this signed cookie in the client side
Now the cookie parser middleware that
we set up with our Express server already supports signed cookies
Now for this in the cookie parser
you will also supply the secret key as the parameter for the cookie parser when
you set up the cookie parser middleware
Thereby all the cookies will be signed
appropriately and then sent out
And when the cookie is parsed on
the server side in the incoming request message this will be added into
the request message as req.signedCookies
And then you can have a specific field
which you can check in the signed cookie
Cookies are very useful way of your client being able to send information
whereby your server recognizes the client
But of course cookies have limitations
They are a fixed size so
they cannot encode a lot of information about the client that their server
can retrieve from the cookie
The cookie is used to just
remind the server about which client is sending the request
Now if you want to have a more elaborate
mechanism to track information about a client then on the server side you
can set up what are called as sessions
Now sessions is a generic mechanism
that is available with any servers
In particular
we'll look at Express itself and how Express supports session
management on the server side
The way it works is that the user
session is set up on the server side
So this session itself is
a combination of a cookie and a session ID and
the server side tracks information associated with that session ID
or indexed by that session ID
The session information
itself can have any amount of information being tracked on the
server side and indexed by that cookie
So when a client sends a request over
the server then from within the cookie the session ID is retrieved and that is
used as an index into the server side
For example if you are using a server side database
that index will be the primary index into that particular server side
database which tracks the sessions
And thereby additional information
about that session can be retrieved and used by your server in order
to make decisions on how it services the incoming client request
Now by default the sessions are stored
in memory on the server site
Now obviously what this means is that
if your server is restarted your memory will be cleared and so all the session
information will be gone completely
So instead many servers will resort to using some form of permanent storage
where the session information is tracked
The permanent storage on the server
side could either be done through some kind of a file storage
Or even leverage the fact that you already
have a database on the server side and than store the session
information on the server side
For example in your MongoDB itself
Now in the exercise that follows we will
look at the use of a file storage for tracking session information
on the server side
Another aspect that you need to pay
attention to is the fact that if you are having a distributed server
implementation whereby multiple servers are acting as the server for
servicing the request
Then the distributor server should be
able to access the session information
Any one of this servers should be able
to access the session information
So you will need a distributor
sessions tool on the server side to enable you to support
multiple replicated servers
Especially this is useful when we
are trying to ensure reliability of server operation
Now again we won't get in too much of
details about those in this particular course we will rely on understanding
basically how Express sessions work
Coming specifically to Express and how sessions management
is supported in Express
Express uses the express session
middleware that supports the use of sessions in an Express server
Now you install
the express sessions middleware
And in the exercise
I'm going to use the FileStore as a way of permanently storing
the session information
And so we will also include
the session file store node module that enables us to use the files on the server
side to track the session information
We'll see the details in
the exercise that follows
And then once we do that your session
itself will be set up on with the new express server by declaring
the middleware here as session which takes a certain set of options
as a parameter here
The options include the name for the
session so we'll give the session id for the particular session
And then you'll also supply the secret
a secret key that is used for encoding the signed cookie that'll
be sent to the client side
And then also additional information
including saveUninitialized which will be a flag that is used and
also a resave flag that is used
We'll look at some of the details
of these options in the next slide
So all these options are specified here
And if you are FileStore as
the permanent storage for your sessions then we will declare that also
in the session options there
So this is how we would set up
a session on the express server side using the express session Middleware
And the express session Middleware
when the client sends this information this will be parsed on the server side and this will result in a property called a
session being added to the request object
So this session information will
be accessible in the request object as req.session
So the req.session will carry additional
information about that particular session for that particular client
Now once this session incoming request
is parsed by the session middleware the req.session property will
be added to the incoming request message object that express uses
So after the session is parsed direct
session property will be available and we can examine that too to check
which client has sent this request
When they setup their session
object on server site as we saw we can setup various
options for that server site
The cookie the options from the session
ID cookie and the default value for the cookie will be as shown here
which is path: '/' httpOnly: true
secure: false maxAge: null
So this will be the default value of the
cookie that will be stored on the package and sent over to the client's
side as a signed cookie
And this would be included in every
incoming request from the client's site
Then the genid is the function
that generates the session ID
The default is to use the UUID of
the server itself as the general ID
Then the resave flag if it is true
forces a session to be saved back to the store even if it's not
modified by the request
Sometimes the incoming request may contain a need to modify the session
information on the server side
And so if the session information is
modified it'll have to be persistent
If not then you don't need to persist it
But if you set the resave flag to true
even if the session information on the server Is not modified by the incoming
client request it'll still be resaved
The next flag that we looked
at was saveUninitialized
If this is true it'll create a newly
created session without any modifications to be saved of the session store
Now we will set this to false by default
which means that we only will track those sessions that
are authorized on the server
Now the secret as we see is the secret
key that is used for signing the cookie and the store itself specifies
the session store instance that is used
The default is to use the in memory store
You can specify the file store or
Mongo store for storing that session information
and so on
So once you specify this information for
your express session middleware then the session will be appropriately set up
and so will be tracked on the server side
Each client request will then be
mapped to the session information on the server side when the client request is
parsed by the express session middleware
And the req.session will be
added into the request object
With this understanding of cookies and
express sessions let's move on to the exercise where will look at
how we will make use of cookies first
And then we'll look at how we will
make use of express Express sessions within our Express REST API application
that we have been working on so far
Now that we understand about cookies and express sessions in this exercise let's look at cookies in particular
We will see how we can use the cookie parser middleware to set up and handle cookies within our express application
Going back to our ConFusion Server Express application that we have been working on so far you will notice at the top that the cookie parser is already included in our express application
If you need to explicitly install cookie parser you just need to type "npm install cookie parser minus minus save." But since our Express Generator has already included the cookie parser into our express application that we scaffolded out we don't need to do that step in this exercise
So you see that the cookie parser is already included there and then if you scroll down you would see that in the code right below here you would see the cookie parser has already been included into the middleware there
Now for this cookie parser we will be using signed cookies in this exercise
So for this cookie parser I'm going to supply a secret key as the parameter here
The secret key could be any string there so I'm just going to supply a string like this I'll say 12345 67890
It doesn't have to be anything meaningful it's just a key that can be used by our cookie parser in order to encrypt the information and sign the cookie that is sent from the server to the client
So once we set up our cookie parser to handle signed cookies so then within the authorization itself so you see that we have the authorization that we have built in here
Now within the authorization what we're going to do is the first time that the user tries to access the server we will expect the user to authorize himself or herself
Thereafter we will set up the cookie on the client side from the server and then subsequently the client doesn't have to explicitly keep sending the basic authentication information
Instead the client will simply need to include the cookie in the outgoing request
Since we are using signed cookies here so when the incoming request comes in so we will handle that inside the authorization
Now you recall that we have already set up the authorization middleware here
So we're going to modify this authorization middleware to make use of cookies instead of the authorization header
So what we will do here is that we'll say "console.log" and then we will "console.log(req.signedCookies)" so that we see what is actually included in the signed cookie here
Now also after this what we will do is we'll say "If (!req.signedCookies.user)"
User will be a property that we will set up in the signed cookie as you will see a little bit later how we will setup the signed cookie
So if the incoming request does not include the user field in the signed cookies and then that means that the user has not been authorized yet
So in that case what we will do is expect the user to authenticate himself
So then we will do all this part here
So notice that we had already done this earlier where we were handling the authentication header
So we will take all this part all the way up to this "else" here and then include that inside here
So essentially what we are specifying here is that let me indent it
As you see I am very particular about my indentation because that keeps the code more easier to read
So inside this if so this is the closing point of the if of this one here
So we are saying if the signed cookie doesn't contain the user property on it then we expect the user to authorize by including the authorization header
So we'll look for the authorization header
If the authorization header is not available then we will simply reject the user and prompt the user to enter the username and password as we did in the previous exercise
If the authorization header is included then we will process the authorization header just like we did before and if the user is an authorized user recall that we called the next to let the user proceed forward
Now at this point what we will be doing is that we will say we will set up the cookie at this point
So this is where we will use the res cookie here
Notice that the cookie doesn't exist so we'll say "res.cookie." As you can see the res cookie itself takes the first value name string value string and options cookie options
Set the cookie name to value with the given options and the options are included here some options for the cookie here
I'm going to simply use a few of the options here
So we'll say "res.cookie" and then I'm going to set up the cookie with the name user
Now notice that this is the reason why I am checking for the req.signedCookies.user up there
So we'll say "res.cookie('user')" and the user field I will set it to 'admin' and then I will set this up to be a signed cookie
So I will say "signed: true." So which means that my cookie parser will ensure that this cookie will be signed and setup
So this is the option that I set up for the res cookie here
So this will include this particular name into the signed cookie with this particular value
So that is the reason why I'm able to check that value up here
So if this doesn't exist then of course I expect the user to authenticate by using the basic authentication and if the basic authentication is successful then I will set up the cookie here and set up the cookie field in the outgoing response message here and this will prompt the client to set up the cookie on the client side and then all subsequent requests will include this cookie in the client request
So that is how I am handling the fact when the cookie.user doesn't exist
There
If it exists then the else part so that means that the signed cookie already exists and the user property is defined on that then in the else what I will check is if req.signedCookies.user is admin
Then that means that the signed cookie contains the correct information
Then I will say next
So which means that you will allow the request to pass through
Otherwise this cookie is not valid because it doesn't contain this correct value
So that means that this is an error
So in this case we will say you're not authenticated and then we will simply cause the error in this point
Now we're not going to prompt the user for the session because that must have been done earlier
Now normally this would not happen because if the cookie is already set on the client side then it must include the correct value anyway
But for the sake of completeness I have also included the else error check here at this point
That's it
With this setup we have turned our express application into one that handles cookies here
Note again let me draw your attention to what we're doing here one more time
Here we are checking to make sure that user property in the signed cookies doesn't exist or even the signed cookie itself doesn't exist
Then we will expect basic authorization to be done
If the authorization is successful then I am going to set up the cookie by using the res.cookie here
Then all subsequent requests will carry the signed cookie anyway and then so I'll check to see that the signed cookie is a valid signed cookie and contains the user property which is set equal to admin
If it does then this is an authorized access so it'll allow to proceed forward
If not then I raise an error at this point
Minor correction the new versions of Node.js expect you to use this as new Buffer.from instead of new Buffer in order to deal with some security issues
So just correct this line to new Buffer.from
That's it
Let's save the changes and then go and look at our application in that Postman
If the previous server is running just stop it by typing Control C and then restart the server by saying npm start
Of course make sure that your MongoDB server is up and running
Otherwise your express server will not start correctly
So once your express server is started then let's go to our Postman and try to connect to the server
And I'll demonstrate a few aspects about how cookies are handled
Now going to Postman let me clear out all this information from my Postman and then we'll start with the basics
So let me try to access the localhost:3000/dishes
Now after I have cleared everything I'll send the request and save
And so from the server side it says you're not authenticated
Then when you look at the header this is asking me to authenticate using the WWW Authenticate
So now let me go into the authorization and then set up the basic authorization and then I'll set up the authorization as admin and then password and then update the request so that the header will now contain the authorization header here with the information there
And then let me send the Git request on this part
If I send the Git request then in response you see that the Git request was successful
Note also a few more things
You'll see the status is 200 OK
Note also that a cookie has been set up on our client side in within Postman here
This cookie contains information
We'll look at the details of the cookie in a minute
Then when you look at the header you see in the header this value here saying Set Cookie and then this information that comes in here
Now if you look at it carefully you'll see something here says user equal to and then you see this value here admin there
So you notice that something has been enclosed inside the cookie
If you want to actually examine the cookie go up here in Postman and then click on these keys and then this will show you all the cookies that have been set up on this client side
Then in particular now let me clear out all these other cookies
I probably have used some of these for some other reason
So let me just clean out those cookies
Anyway if you see them you can just leave them there
Not a big problem
Concentrate specifically on the local host here and then you see this cookie here
Just click on the cookie and then you see the actual value inside the cookie that is stored there
Then also the expiry date for that cookie setup here
Now this value will be exactly what you saw in the set cookie that came in from the server side
Now this also means that in subsequent requests that go in so even if I clear out my authorization and even if I remove the authorization header because the cookie has been set up this cookie has been set up on my local host every subsequent request going to this this server will include this cookie
So even though I would not have the headers set up there if I send the request you will notice that the Git request works just like before without any problem because of the fact that each outgoing request will automatically include this cookie in the outgoing request from my Postman here
This demonstrates the use of cookies in our application
With this we have seen how cookies can be set up and processed in our express server using the cookie parser and how we can set up signed cookies
This is a good time for you to do a git commit with the message cookies.
In the previous lessons we have seen various strategies for user authentication
We started with basic authentication and then moved on to cookies and express sessions as a way of authenticating and tracking users
In this lesson we will look at Passport a node module that makes authentication quite easy unobtrusive and straightforward to configure in your application
Passport is nothing but an authentication middleware which supports various strategies that can be used for user authentication including a local strategy like using username and password or even third party authentication or using OAuth or OAuth 2.0 like using Facebook Twitter or Google+ and so on
We will look at some details about Passport the local authentication supported Passport
And in the exercise that follows we will update our application to make use of Passport and Passport Local Node modules to enable
local authentication using username and password
So as I stated a little bit earlier Passport is a very useful authentication middleware for Node.js applications
It makes it simpler to implement authentication
As we have seen in the previous exercises authentication involves a lot of repetitive code and repetitive tasks handling errors and devising ways of checking the user authentication and then authenticating the user and so on
All this is simplified within Passport using various strategies that can be used for authenticating users
You can use a local strategy for example which is based upon registering users into your system using a username and password and then thereafter authenticating them using the username and password
Passport also supports OpenID based authentication or OAuth or OAuth 2.0 based authentication as is supported by third party authenticators like Facebook Twitter Google+ and so on
We can also use what is called as JSON web tokens as another way of authentication called token based authentication
We'll look at token based authentication in the later part of this lesson
Also Passport supports sessions
As we have seen in the previous exercise and the previous lesson express sessions are a easy way of tracking users on the server side and being able to service incoming requests from clients
To make use of Passport of course we'll install the Passport module
We'll also in the exercise that follows install the Passport Local module for providing the local strategy for user authentication
The use of Passport within our application is fairly straight forward
On the routes on which we want to perform authentication we just specify passport authenticate and then specify the specific authentication strategy that we want to use for the user authentication
As an example here you see that we are applying a local authentication by saying passport authenticate and local
And so it uses the local strategy for authenticating the users
If the authentication is successful then the middleware moves on to the next step where we can further process the incoming request
So upon completion of the successful authentication of the user passport Passport itself adds a user property to the request message
So req.user becomes available for us with the user's information in there which we can subsequently use within our express application to handle the request coming from specific users
So this easily helps us to identify which client sent the request to our application and consequently service the request accordingly based upon the user's identity
Together with Passport we will install another Passport related module called Passport Local
Passport Local supports a strategy called as the local strategy for authenticating users with the standard username password combination
So we set up the user schema as we did before and then use the user schema or model to track the username and password and then Passport Local depends upon that to verify the username and password
So to install it again being a Node module we install it using the standard procedure for installing the Passport Local Node module
Once the Passport Local Node module is installed then we need to specify the local strategy and how it is actually used within Passport
So to specify a local strategy we'll say; passport.use and so this will allow us to specify the local strategy to use
So having installed the Passport Local we will declare a new local strategy and then supply the corresponding verification function that is used for verifying the user
If you are using a MongoDB as the back end store then to help us with Passport Local strategy there is another module called as Passport Local Mongoose
The Passport Local Mongoose module provides a Mongoose plugin which will simplify the username and password login
By installing the Passport Local Mongoose plugin and then using it when we define the user schema and the model and thereby using the support of the Passport Local Mongoose module this mongoose plugin adds in the username and a encrypted way of storing the password within our user model
The encryption is done by using hashing on the password that we use for registering users and the hash itself uses a salt field
So if you know anything about cryptography in cryptography the salt is a random string that is used for performing the hashing operation on the password for storing
So the hashed password is itself actually stored in our MongoDB database
The actual password is not stored
So when the user tries to authenticate using the username and password the password will be hashed again and then compared with the hashed passwords stored in our database and this is all provided by the Mongoose plugin the Passport Local Mongoose
In addition the Passport Local Mongoose also adds in additional methods that are very useful for configuring the Passport Local strategy
So within our application when we define the user schema and the model we will import the Passport Local Mongoose and then add in as the plugin for the user schema
This Passport Local Mongoose module automatically as I said adds the username field and also a hashed password storage field using a salt value that it uses for doing the hashing and also provides additional methods that enable us to configure our Passport Local strategy
If we are using the Passport Local Mongoose module then the local strategy the Passport Local Mongoose plugin supports on the user model an authenticate method that will automatically do the authentication
In the earlier slide I had shown you how we would implement the local strategy
Now this is automatically provided for you by Passport Local Mongoose by simply saying new localstrategy user.authenticate
Then we don't need to explicitly write the authentication code for the local strategy
Also if you are using sessions that are supported by Passport then for supporting sessions the user information needs to be serialized to be stored with the session information on the server side and then when the request comes in from the session ID the user information needs to be deserialized to extract the user information from our session information that is stored on the server side
Now this serialization and deserialization operation is already supported by Passport Local Mongoose through the serialize user and the deserialize user methods that are available from the Passport Local Mongoose plugin
So having seen this we will now see in the exercise how easy it is to configure local strategy for authenticating users using Passport Passport Local and Passport Local Mongoose Node modules.
 In the previous lessons we have seen several different
kinds of authentication schemes
We started with basic authentication then
we looked at how we can use cookies for doing authentication and
even signed cookies and thereafter we looked at
session based authentication
Where the server is keeping track of
information about each client and then the cookie will be used as a way
of indexing into the server side database to extract additional
information to validate the user
Now the cookie and session based
authentications are not scalable because there server needs to keep
track of all the different users
Even though this is done outside
the HTTP protocol itself but still the fact that you need to keep track of all the section information of the
server site makes it not very scalable
So this is where token based
authentication has proved to be very useful
we'll look at token base authentication
a little more detailed in this lecture and exercise that follows
Again quickly reviewing cookies and
session based authentication
With cookie based authentication we notice that cookies are stored on the
client side and the cookies are included in every outgoing request message whereby
the server is reminded about that specific client
by extracting information from the cookie
Cookie can be used together with sessions
whereby the cookies store the session ID and then when the server receives
the incoming request from the cookie it extracts the session ID and uses that
as an index into the server side session store to retrieve the session
information for the particular client
Now this approach as I said is not very scalable because if you have
thousands of sessions the server needs to keep track of all these thousands
of sessions on the server side
Even though it is done
independent of HTTP in a store either a file store or a database
But still the fact that you need to track all of
these information makes it not scalable
So again to remind you one more time why do we talk about
token based authentication? Session based authentication as we have
seen earlier works perfectly fine for web applications and can easily
take care of user authentication
But then session based authentication
while it's the principle of stateless servers and
also leads to scalability problems
The second issue is
mobile applications do not handled session based
authentications very well
Similarly mobile applications have
a hard time dealing with cookies
So in such circumstances where
your server is serving data for both a web application
as well as a mobile app
Then the session based authentication
will not be very useful and this is where token based authentication
becomes a lot more easy to use
In a token based authentication
as the name in place the server will issue a token to
a validated user and all subsequent requests coming from the client side
will bear the token in the request itself
Either in the form of a request header or
in the body of the request message
Furthermore token based
authentication also helps us to deal with what are called CORS or
CSRF problems
Cross origin resource sharing problems and
so on I'll briefly talk about
cost in the next module
But for the moment token based
authentication addresses some of the issues that lies with cars and
cross site request forgery related issues
Not only that token based
authentication is a lot more easy for one application to share its
authentication with another application
Of course
this is all done in a secure manner
But with session based authentication
that is not straight forward
How does token based authentication work? In token based authentication the user first needs to validate
himself or herself on the server side
Now this validation could take on
the forms that we have seen earlier
So we can use a local validation
using username and password
Or we can even use third
party validation using technologies like oauth or
oauth 2.0 or open ID
We'll talk briefly about oauth and
oauth 2.0 in the next module
But no matter which way the user
authenticates once the user is authenticated right after your server
can simply issue a token to the user
And all subsequent communication
between the user and the server
can be done simply using this token
JSON Web Token that we will talk about
is one such token based authentication scheme and there server when it creates
this token it will create a signed token
Using a secret on the server site
which only the server knows
So thereby even if a third
party in towards and between and tries to manipulate the token
even if it captures the token and tries to manipulate the token
the token will become invalid
And so that way of protecting the user is easily feasible all subsequent requests from the client side should
carry the token in the request either as I said in the header or
in the body of the request message
So when the server receives this token
the server will verify the token to ensure that this is a valid token
and then if it is a valid token the server will then respond
to the incoming request
As I mentioned JSON Web Tokens is one
such token based authentication scheme
JSON Web Token
is a very simple way of encoding information in a token then
pass it to the client site
JSON Web Token itself
is based on standards this is based on the IETF RFC 7519
IETF here stands for
the Internet Engineering Task Force
The organization that mandates
everything about how the internet works and deals with the protocols and
the policies related to the internet
The RFC stands for
the standards document in IETF terms RFC stands for
Request for Comments
And each such standards
document carries a number
7519 in this case refers to the document the standard document
related to JSON Web Token
The JSON Web Token itself is a self
contained token it carries all the information within itself
that is necessary to identify the user
Not only that a JSON Web Token can
be shared between two applications
So for example one application when
it authenticates and then gets hold of a JSON Web Token can pass that
JSON Web Token to and in that application that it is willing to authorize to
access the server on its behalf
This sharing of the token is
done in a very secure manner so don't worry too much
about security in there
This is not in a secure manner where by the sharing of the token
between one application to another
Thereby the authorization is transferred
over to a second application and the second application can authorize
on behalf of the first application to communicate with the server
This is feasible with tokens
Now of course the engineer in you will
obviously be wondering what exactly is inside a JSON Web Token
and how is it useful? A JSON Web Token as I said
is encoded into a long string and this string itself can be interpreted
as consisting of three parts
The string itself can or the encoded
string itself contains three parts the Header the Payload
and the Signature
That carries enough information
about how this token is encoded
The Header itself contains the specific
algorithm that is used for encoding this JSON Web Token
and the type of the token itself
The algorithm in this case would be
HS256 which is a 256 bit encoding scheme that is used for hashing
the information inside of the token
And in this case this happens
to be the JSON Web Token and so the type field will be set to JWT
And so that is the information that is
stored in the header of JSON Web Token
The Payload itself carries information
that helps you to identify the user
In the exercise that we will do the hour payload only carry the ID
of the user inside the payload
No other information is necessary
This ID can be used on the server side to index into the Mongo DB to retrieve
the full user information if required
So you will see that
we'll encoding the ID and then storing it in
the payload of that message
You can store additional information in
the payload of the message if you require
But the more information
that you stored there the larger the corresponding
JSON Web Token is going to me
So try to limit the amount of information
that you stored in the payload of the JSON Web Token
As we will see in the exercise
we have a node module that enables us to encode and create a JSON Web Token based on the information that
we want to put in the payload
Now when you create a JSON Web Token
you also supply a signature
A secret key on the server side which is
used for encoding this JSON Web Token and that secret is also included in
the signature part of the JSON Web Token
The signature itself is included
in such a way that there is a basics before encoded header and
payload which is then encoded using the specific
secret that is used by the server
And this encoded in as I said the HMAC that we have referred to in one
of the previous lessons and using the 256 bit hashing and
that is included in the signature
So when this JSON Web Token is
received on the server side and when the server decodes this token
then the server is able to cross check to make sure that this JSON Web Token
has not been tampered by anybody while the token is being passed between
the client and the server site
So if you know anything about security
and intruders and so on you understand why it is
important to encode the token and verify the authenticity of
the token on the server site
As I mentioned if you need to deal with
JSON Web Tokens in your node application
There is a specific node module called
as the jsonwebtoken Node Module
This node module implements
the JSON Web Token related standards and it can be included into
your node application
This module itself provides a method
called sign which allows you to sign and issue the token to the client
from the server side
It also contains a verify method
Which can be used to
verify the authenticity or to ensure the authenticity of
the incoming JSON Web token so we will be making use of the JSON Web
token module in our exercise
Together with the JSON Web Token module we also used the Passport JWT module
node module
Which provides the jwt based strategies
for our passport authentication module
So this provides a passport strategy for
authenticating using JSON Web Token
So this allows you to authenticate RESTful
endpoint using the JWT as the method for dong the validation without
requiring the server to use sessions
Now the JWT passport module supports a method of even
extracting the JWT token from the incoming request message and then
even verifying the token on your behalf
The Passport JWT module intern
uses the JSON Web Token module for doing the verification
of that JSON Web Token
The token itself can be carried in
the header of the incoming request in the header even in the authentication
header of the incoming request which is what we will be
doing in the exercise
The token can be also carried in the body
of the incoming request in which case we have to extract the token from
the body of the incoming request and then make use of it
The Passport JWT module
supports that also if you choose to use that as way of passing the token
back from the client to the server site
The JSON Web Token can be also included
in the URL query parameters if you so choose to and can be extracted
from there b Passport JWT and used for authentication
Now with this quick understanding
of JSON Web Tokens and how they are useful we will move on
to the exercise where we will use the Passport JWT module
together with the JSON Web Token module and configure our Express Rest API
server to use JSON Web Tokens
I guess by now your head is infested
with mongooses or is it mongeese? Well I'm no English major so
I have no clue what the plural is
In any case that brings us to the topic
of this lecture Mongoose population
What exactly is Mongoose population and how is it useful in our
express application? Let's talk about that next
As we realized document databases
the NoSQL databases are not designed with relations in mind
Everything that you need in a document is
stored completely within the document
Well that is pretty much the way things
operate with NoSQL databases like MongoDB
So you do not have support for
relations that you might be more familiar with from
the relational database world
Where you have records and then records
can reference other records and so on
And then you do joins in order to join the
information from the records and so on
So that kind of support doesn't
exist in NoSQL databases at least to a large extent
MongoDB has taken a few steps in that
direction even with the NoSQL databases
But in general document databases expect
that all documents are self contained
So which means all the information that
is required is within the same document
Now of course there are situations
where you have other documents that already contained the information
And you may want to pull that
information into your existing document rather than duplicating that information
So this is where MongoDB or Mongoose allows you to store references to other
documents within a current document
The reference to the other document
is done by using the ObjectID of that other document
Now if that is the case then Mongoose
allows you to perform a way of taking the information from the other
document and then enclosing it inside the correct document using
the Mongoose population support
That is what we will discuss
in a little more detail
Mongoose itself as we realize
being a module built on top of MongoDB
doesn't have explicit supports for joins the way we talk about
joins in the SQL world
To understand how this referencing of the
other document in a document helps us and how it is actually structured
let's take a look at an example
In this example
we'll look at the dishes document that we have been using in our exercise
In the dishes documents that
we store on the server side we noticed that we also
store the comments
And within the comments we also store
an author field within the comments
And author field explicitly
contains the name of the person who submitted that specific comment
Now since we already
have a users document within our database
as we saw in this module
We had extended our expert server
to support users and thereby you can register a user and
that you can authenticate users and so on
So the user document can carry additional
information about the user already
And so
when a comment is posted by the user instead of storing the user's
name within the comment itself why not have a reference to the specific
user that has posted the comment? This is helpful not only
in terms of being able to deal with the fact that this comment
is posted by the specific user
Later on we will see that if you
need to allow users to modify or delete documents
you may wish to restrict the kind of operation of a specific
user to only those comments that that specific user
has posted earlier
Even though we are using sub documents
within our Mongo document
If we can reference another document
in the sub document using ObjectIds then Mongo helps us to
do population of this information from the other document
into the current document
So this is where Mongoose
population comes to our rescue
Taking this idea further
let me show you a detailed example from the comment schema
that we have defined earlier
So in the commentSchema
we already have the rating field and the comment field which we
have already specified there
We also used to have
the author field earlier
For the author field earlier
we were storing the author as a string and
The default value also for the author
Now in storing the author as
a type string if we now turn the author into a type of
mongoose.Schema.Types.ObjectId
So which means that the author
field now will contain an ObjectID which is a reference to a user document
How do you ensure that this is
referencing a user document? So this is where this additional property
called ref which specifies that the schema of the document that you are
referring here is of the type the User schema and the model that we
have already added earlier
So in this case the comment schema is now
extended to store the author information but the author information
is in a form of an ObjectId
Which is a reference to the user document
that is already stored in our database
Now how does this help us? This is where as a I said
Mongoose population comes to our help
So how does Mongoose population work? With Mongoose population
the way Mongoose population works is that it automatically replaces specified
paths within a current document
Which has reference to another document by
the information from that other document
So in the comment schema for example
you have an author field that is referring to the ObjectId of the user
document that is already in your database
So with Mongoose population when you ask
Mongoose to populate this dish document then it'll populate the information
about the author in the comment field from the user document
So the information about the specific
author that is referenced there will be fetched and added into your dish document
And the compound document will be
constructed and then sent back to you
How do we ensure that this happens? This is where that cross referencing with
the ObjectId as we have seen helps us
How does the population
actually happen in code? Taking a look at how we would populate
for example the dishes document
we have just seen earlier
Earlier we were doing Dishes.find to
find all the dishes in our database
Now once you find the Dishes document
then you can say populate
And then supply within the populate
as a parameter the specific field that
needs to be populated
So here we are specifying comments.author
Now the expectation is that
the comments.author field is actually an OjectId which
references to the user document
And that is how we have set up
our comment schema already
So this populate call that we
perform here will then go and fetch from the database each individual
author's record or the user's record
And then take that user document and populates it into the dishes document to
construct the compound document from here
And then after that of course there some is subsequent handling
of data that you have obtained
And then replying or returning the data to
the client can take place at this point
But of course let me caution you
that this population operation is not an easy task for the server to do
Because every single dish you will
have to examine each and every comment
Then for each and every comment then
you need to find out their ObjectId for the user
Then you go and
fetch that user document and then populate it inside the dish document
And then that has to be repeated for every single comment that is
contained in that Dishes document
It essentially means that it'll take
a much longer time for the server side to complete the request and send back
the information to the client side
So I would suggest that you should
use populate very judiciously
You should use it only in circumstances
where you really need that information
If for example you're simply
constructing the menu for your restaurant
When you're just constructing the menu for
your restaurant you may not really need to populate
the information about the author of each comment into the comment document at all
Because when you are just rendering
the menu for your restaurant you are not going to be showing
the comments for that specific dish
But instead if the user is
examining a specific dish and wants to see the comments at that point you may wish to execute
a server side request
And then fetch the comment information
with the other author information populated in and obtain that for
use within our client side
So again populate is a wonderful
way of doing things when required but use it very judicially only when
you really require the information
So that flexibility that
populate provides for us is the fact that we don't need
to populate when we don't have to
But we can populate the information
when we really need that information
With this quick understanding
of Mongoose population let's move on to the exercise where
we will modify the Dishes schema the comments schema
within the Dishes schema
And then use Mongoose populate to populate
the information within our dishes when we are returning the dish
information to the server side
Also this also implies that when a
comment is being added to a specific dish the author of the comment's information
has to be captured on the server side
Now it so happens that the way
we have developed our servers we already have this information
being provided for us
When we authenticate the user the user's
information is already loaded into every request that comes in
from the client side
And so they use that user
information's available to us
So when we are posting the comment
on the server side we will also capture the user's ID and then store it in
the author field of the comment schema
This should be done automatically
on the server side
The client should not be allowed to
fill in the author field explicitly
But the server side should
validate the user and only for users that are signed in you would allow
them to first of all post comments
And then when they post comments you will automatically fill in the author
field for that comment document by substituting the author field
with the ObjectId of the user
Now in the exercise
you will see me doing that
So watch out for
that specific thing in the exercise
With this we complete this lecture let's proceed on to the exercise to
examine the use of Mongoose population
Now that we have learnt about Mongoose Population and how it enables us to populate one document with information from another document
In this exercise we will modify the express server that we have been working on so far
In the dish schema that we have defined earlier we had comments
For the comments we had the author field that we use to store the details about the author
In this exercise we will turn the author field into a reference to a user document and we will use Mongoose population to populate the information into the dishes document as and when required in order to supply the information to the client
Now the use of populate and Mongoose population should be done judiciously so as not to cause too much of overhead on the server side
Now in this exercise we're going to use it simply to populate the information into the author field of our comments
So let's proceed with the exercise to learn how we use Mongoose population
To get started on this exercise go to the project and open the user.js file
So in the user.js file we store the user schema
I'm going to modify the user schema by adding in a couple of more fields in there
One is the first name which will be of the type string and the default would be an empty string
So the first name as the name implies stores the first name for the user and then we'll have another field called last name which is also of the same kind
So I'm just going to copy these two pieces of information and then copy it in here and so now our user document will contain in addition to the username and password username and hush and salt that we have seen earlier that is automatically added by the passport local Mongoose module
We will also have the first name and last name for the user being defined here
Later on we will see how we would initialize these values by modifying the user's registration process
Now once we have completed this so this way the user's information can simply be retrieved by looking up the user document here
So now that we have the information about the user in the user document going into the dish schema so going into dishes.js file
In the dish schema earlier we were storing the author of the document in the form of a string here
Now we're going to be taking advantage of the fact that we have the support of mongoose population
So I'm going to turn the comment field from a string into mongoose schema types object ID
So this way sorry wrong field
I meant to turn the author field into mongoose schema types object ID
So the author field now instead of storing a string will have a reference to the user document
So when I turn the author field into this type then the second property that I defined here will be a reference which would be a reference to the user model
So this way we are now going to be connecting this author field and this author field will simply store a reference to the ID of the user document instead of storing the details about the author in the form of a name
Now when we do that we can use mongoose populate to populate this information into our dishes document whenever required
So with this modification to the dishes schema in dishes.js file we'll now update the dish router to use the mongoose population
So going to dishRouter.js
In dish router recall that when we were getting a dish here now when you get the dish here we say dishes find then
So right at that point we'll say dishes find and we will say after this populate
So we are using the population support in mongoose and we'll say populate comments author
So by stating this we are saying when the dishes document has been constructed to send back the reply to the user we're going to populate the author field inside there from the user document in there
So this call to the populate will ensure that the other field will be populated with the information as required
Similarly going to the dish ID here even in the dish ID same thing
We will say populate and comments author added into the dishes find by id in the get of the /dish ID endpoint
Similarly in the comments also when we retrieve the dish we'll say populate comments author here and the same thing also in the dish router dish ID comments comment ID also
The bigger populating this information there
Now of course what this means is that when you are posting the dish earlier you are including the author information in the body of the message
So now here when we try to push the comment into that so this post corresponds to the dish ID comments field
So this is how we were posting a comment to a specific dish
So now in this post since we are not storing the information about the author anymore so what we need to do is when we push the item into the author field there
So here when you're populating the information into the dish we will have to first  Recall that the body contains the comment already but the author property will not be there in the body of the message in the book but depending on which user is posting this information we can immediately populate the author field
Now how do we know which user is posting this information? The fact that we have done the verify user here for the post means that a specific user is posting this information and by doing the verify user we would have already loaded in the req.user into the request object
In the request object we can go in and say wreck user and then underscore ID here
So again let me reiterate this point how are we obtaining the author's information here? Now recall that we updated the dishes schema so that the author field in the comment will simply store the object ID referring to the user that is posting this comment
Now how do we know which user is posting this comment? Now again to reiterate this point recall that when we verified the user here by calling authenticate verify user the passport authorized JWT would have loaded the user information into the request body in the form of req.user
So that user will contain the ID of the specific user that is actually posting this comment
So we have already verified the authenticity of the user and so the user ID can simply be obtained by saying req.user
_ID and that user's ID I will assign this to the author field off the comment
Now when the comment comes in the comment in the body of the request message will only contain the rating field and the comment field
Now we don't want to explicitly send the author field anymore from the client side instead that should be automatically inserted on the server side based upon the authenticity of the user That's the point that I had been reiterating in this modification that I have done here
So that users information is automatically obtained from the req.user that is loaded into the body of the request message by the authenticate verify user which is going to use Passport authenticate with the JWT strategy there
In addition now when we receive the updated dish here we need to populate the author's information into the dish
So at this point when we receive the dish here we are then going to search the dishes here
So we'll say Dishes.findByID and then supply the dish ID as the parameter here so we'll say find by ID dish ID and then we need to populate the comments author here and then we'll say then dish
Inside there we're going to be sending this dish information back to the user here
So let me cut that and paste that in here
So this modification is required because now I need to populate the author's information back into the comment before I can send the current back to the user
So this is the additional modification that we need to do when we use the Mongoose population here
Similarly now going into the put when we modify a specific comment with the comment ID so this is under the dish ID comments comment ID part
So when we do the put here so we first find the dishes find by id req params dish ID then in the dish
So the first thing that we check is to ensure that if the dish is not null and the dish comments ID is not null so we checked to make sure that the comment is indeed present in the dish and then when the dish itself is returned then we need to search again for the dish because we need to populate the comments author into the dish
So here we'll say dishes.findByID (dish ID) the reason we need to do one more search is because we need to populate the comments.author here so that's the only reason why we need to do one more search here
Then when we receive the dish here obviously because we just updated the dish so the dish information should be found in the database so that should work fine and then inside there will say risk status code 200 res set header content type application json and then return the dish here and then we'll handle error here and then the other ones if the dishes now and also the other errors that we have set up earlier they will be handled as usual here
So these are the additional changes that we need to make sure when you update the dish when you're sending back the updated comment or updated dish then we will populate the comment in the dish here
Similarly going to the delete here and then after the delete the comment again we're going to be fetching the dish and populating the author information
So let me just copy this part and then we'll be doing exactly the same thing here so we'll say dish save then we're going to be then checking dish.findByID (dish author) and then we'll populate the comments author and then we'll say (then) dish and then res.statusCode and so on and the remaining error handling just like before here
So with this modification to the dish router now the last point that we need to consider is the fact that in the user.js file we have now added into fields the first name and last name field which by default will be empty strings
So when the user is registering we should allow the user to supply the first name and last name in the registration process
Now where does that take place? That takes place in the user's.js
So going to users users.js when the user posts on the slash signup earlier we were only posting the username and password
In addition to those two in the json object that we include in the body of the request message coming in the post request message coming in from the client side we can also include the first name and last name for the user
So when the first name and last name for the user is included so what am I going to do here? So recall that when you say user.register at this point the user information comes in and then you have submitted the username here and you have also assigned the password here which will be turned into the hash and salt by the passport local mongoose
Now if there is no error that means that the user's registration was successful and so at this point what we will do is we'll say if req.body
First name
So which means that the body of the incoming request message if it contains the first name then we'll say user.firstname is equal to req.body.firstname
Similarly for the last name also
So at this point we would have the user available here
See the user is coming in as the second parameter to this callback function here
So we are setting up the first name by changing the first name property inside the user document here saying req.body.firstname
If it exists then we'll set the user's first name to that
Similarly if the req.body.last name is available so we'll also update the user's last name as req.body.lastname
And once we have done these two changes to the first name and the last name then we need to save the modification that we have done to the user
So we have just updated the user
So we'll say user.save then this will return the error or the user
So if the modification has been saved properly then it will return the error otherwise it will return the user value and this passport authenticate we will do it inside this user here
So we'll say user.save(err user)
And then also we need to cross check to make sure that if there is an error in saving the changes to the user then we'll say res status code 500 so let me copy this from there
So we'll say res status code 500 res set header content type application json and res.jason here
Then and we'll return to this point
If there is no error then of course you authenticate the user by calling passport authenticate with the local to ensure that the user registration has been successful and this should be correctly done and when which case you will return this message back to the client side
We need to close this user.save here
So make sure that you close this endpoint correctly
So user.save is closed here and that's it
These are the changes that we need to make to the user
So thereby after the user is registered with the given username and the given password then after the user is successfully registered then we will set the first name and last name field of the user document by using these two here
We want to make sure that the user is successfully registered before we sent the first name and last name for that
So that's why we are carrying out this operation after the user is successfully registered
That's it
Let's save the changes and go and check out the server
After saving the changes let's now go to the terminal and then before I start the server let me first check out my MongoDB and delete the user that we have registered earlier
So we'll say use confusion and then we'll say db.usersfind
So we know that this particular user has been registered earlier but when we register that user we did not register the first name and last name for the user
So I'm going to delete this user and then re  register the user
So to do that using the Mongo rippleI will say db users drop and then we'll say db users find and that should return an empty
No users registered there and then we'll exit the Mongo ripple
And so once we have removed that registered user then let me start my server
And once the server is up and running let's go to Postman and then register a new user along with the first name and last name of the user
Then they will log in as that user and then we'll look at how the Mongoose population helps us to populate the information about the user automatically into the document there
Now going to Postman let me do a sign up of a new user
So I'm doing a post localhost: 3000 users sign up
In the body of the message we had the username and the password already in there
Let me add in two additional fields: first name last name
Then register that user
So once I register the user you can see that the registration was successful
Now let me login as this user
So to log in as the user let me do a post and cross check to make sure
So I'm doing a post to users login
Let me cross check and I see that the username and password is correctly typed in there
So when I log in I should be successfully logged in and I should be able to obtain this token there
Because this token is essential for us to be able to add in a dish to our server site
So after you obtain the token copy this token string and save it because you will need that in the authorization header for the post put and delete operations that you're going to perform later
So let me copy that token
Now normally the way I would keep these tokens is that I'll just open a text document and then copy and paste it into the text document
So that for subsequent postman requests I can simply copy this string and then paste it into the authorization header if required
So let me copy that token and here I have a text document open here
So I'm going to paste that string into this text document
So here we have the token that we have obtained
Let's now go and post a dish to our server
Going back to postman let me post a dish to the server
So this is where I will choose the post here
Inside here I have the dish information that I had used earlier but for the comments now recall that earlier we had author field which was storing a string
So all these comments are not valid
So I'm going to delete all these comments from submission because now we expect the user to post comments on their own
When the user posts comments we will automatically add in the ID of the user into the author field of the comments
So let me post this dish here
Going to the header in the authorization header I'm going to say bearer and then paste the token and then submit
I should do a post on that
So I will say post and so when I post now you see that this dish has been posted on the server side and with the comments array being empty at this moment
So after I post this dish let me copy the ID of this dish
So let me copy this ID for the dish because I will need that to post comments for this dish
Then going to my text editor I'm going to save that ID of the dish here
Now of course once you build your client side your client will automatically have all this information
So your client will automatically be able to send the token and so on
So you don't need to do this cut and paste thing but with postman this is the only way that we can add any information to our postman requests that go out from postman to the server
Now in order to convince ourselves that this dish actually exists let me do a get on the local hostcolon:3000/dishes
When I do a get you can actually see that this particular dish exists on the server side
So let's now try to post a comment
So to post a comment let's do a post and we'll say localhost:3000/dishes slash and the ID of the dish that I just copied and slash comments
When you post on the comments you need to make sure that in the body we will add in the comment here
So a typical comment contains a rating of say five and then comment
So let me just type in some random comment just to demonstrate to you
So this should be in the body of the post for the comments and in the header we should add the authorization header
So for the authorization header we'll say bearer
I need to paste the token here pasting the token value that I have saved earlier
Let's now post this comment
Then when the comment is posted let's look at the returned value here
So as you browse down you can see that the dish to which the comment has been added has been returned
Notice that the dish information is there but note in particular what is contained in the comment that has been posted here
So as you can see you already know that the updated and created at fields are automatically added in by mongoose
The rating and the comment that we submitted are right there but note how the author field now contains the ID corresponding to the user
Now as we saw in the code how the author field information is added now if you do a get on the dishes you will notice that this author field will be automatically filled in by the users information here
So let's now do a get on the localhost:3000/dishes
So when we now do a get on this point you'll now notice that in the dishes here right there the information about the dish is already present but note how the comment is now constructed
The comment now contains the rating comment fields as we saw earlier the updated and created at but note what happened to the author field here
So when you do a get request because we did a populate on the server side when the get operation is invoked the populate has automatically populated the author information into position in the author field here
So in there you can see that from the author you can now look up the last name and the first name information automatically from the author field
So if you need to construct a comment you now have the rating the comment and also the first name and last name of the author automatically included into this document
Also the user name also is included into this document
So this is how you can add in information from another document and populate a second document with that information before you reply back from the server site
So this is the use of mongoose population and how we can automatically populate information into a mongoose document
With this we complete this exercise
In this exercise we have seen the use of mongoose population and we have also seen how we can populate information from one document into another document
Whereby when we modify the server to do the population for the requests mongoose will automatically take care of populating this information for us
All that we need to do is to store the reference to the other document in the form of the object ID in the document into which you want to populate this information
With this we complete this exercise
This is a good time for you to do a git commit with the message mongoose population.

