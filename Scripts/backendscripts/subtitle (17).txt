In the previous lecture, we learned about REST API. You have seen how the REST API endpoints support a way for a client application to be able to either retrieve data from the server or upload data to the server using the various HTTP operations. In this lecture and exercise that follows this lecture, we'll look specifically about what kind of support Express supports for designing and implementing a REST API-based server. In particular, we'll also look at the Express router, and how it enables us to subdivide our application and then organize it into multiple mini Express-like applications, which combine together to form the Express application, specifically when we are dealing with various REST API and parts. So to summarize, in the previous lecture, we examined REST in detail. We also looked at how each endpoint is identified by a URI, and how we can specify the various operations to be done on each endpoint using the appropriate HTTP verb, the GET, PUT, POST, or DELETE. Now in this lecture, we'll look at how Express supports the development of a REST API server. We'll look at Express's support for various matters like app.all, app.get, put, post, and delete, and how these methods can be used to construct a REST API server. Within Express, the various application groups can be defined using the, app. and the various methods. So, the app.all specifies an operation that needs to be done on all the various verbs, on, in, and part. So for example, in this example, we see that the endpoint is defined by /dishes, and so the app.all, whatever is specified in the function that is given for app.all, will be applied to all the incoming requests. The app.get specifies what needs to be done for GET requests and, correspondingly, for the POST, PUT, and DELETE requests which are sent to the /dishes endpoint, as shown in this example. Express also supports defining the endpoints with parameters. So for example, you can specify a specific dish ID if you wish to, and then let the operation be performed for that specific endpoint referring to that specific dish with a given dish ID. So in this case, the dish ID itself is specified as a parameter and the pattern used for that is, as you see in this example, /dishes/: and then you would specify the parameter here. To make it easy for us to understand, I named the parameter as dishId in there. You can use any parameter name that you choose to, but again, using a meaningful name for a parameter makes it more easier to understand the code. So in this example, the :dishId means that if we issue a request to an endpoint, say for example, /dishes/23, then the dishId parameter enables us to extract this number 23 so that we can operate on dish number 23 within the function that is specified inside this method here. So in there, the parameter, the dishId parameter itself can be obtained by using the request object on which the params property you supported and the params property supports all the incoming request parameters, and dishId, in particular, is one of those request parameters which can be accessed, as shown in the code here. When you send a PUT or a POST request from the client to the server, you're often enclosing the data in the body of the message that is sent to the server. Now, which means that we need a method of extracting information from the body of the message. So this is where the body parser middleware for Express is very useful. So the body parser enables us to parse the information from the body of the message. To use the body parser, as we would expect, we would install the body-parser node module, and then require it within our Express application, and then specify app.use(bodyParser). And if the body contains data in the JSON format, you can say bodyParser.json, so which means that this will parse only data that is in JSON format that is enclosed in the body of that request message. In particular, in the exercise, we will be parsing incoming data which is sent in the form of a JSON string. The body parser, as you would expect, parses the body of the message and populates the req.body property. So, on the request, the body property will contain whatever is parsed in from the body of the request message by body parser. If you are implementing an Express application which supports multiple REST API endpoints, then it makes sense to subdivide the code into multiple modules and then make use of them to construct the overall Express application. So this where the Express router comes to our aid. An Express router defines many Express application, and within that many Express application, you can, for example, deal with one particular REST API endpoint in more detail, or one particular pattern of REST API endpoint in more detail. So, for example, we can define a dishRouter as express.Router, and then the dishRouter can then handle the endpoints. So when you express something as express.Router, it supports the route endpoint. One of the reasons for using Express router, as you would realize, is that if we use the standard app GET, PUT, POST, and DELETE methods, for each one of these methods, you need to explicitly specify the REST API endpoints. One advantage of using Express router is that if you say the router.Route and then specify the endpoint, that endpoint will be applied to all the methods and all the various GET, PUT, POST, and DELETE verb-related methods can all be chained together into the route in defining the code for our application. We'll look at more details of this in the exercise that follows this lecture. With this quick understanding of how Express supports REST API endpoint, let's move on to the exercise where we will construct their support for the /dishes REST API endpoint. As part of the first assignment, you will be further extending this Express application to support additional REST API endpoints, including /promotions and /leaders. If you have taken the previous courses in the specialization, you will immediately begin to see why we are supporting all these different REST API endpoints on other server side.