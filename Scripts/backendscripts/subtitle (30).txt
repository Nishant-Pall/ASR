In this exercise, we're going to continue working on the node Mongoose server that we developed in the previous exercise. We will do another variation of that. In addition, we will also look at how Mongoose supports sub-documents, and this enables us to store a document inside a document for storing additional information. Let's look at that in the exercise next. Continuing with the example that we have been working on, now, in the index.js file, now we'll see a new way of creating a dish and adding it into our application. So, earlier we had done var newDish and dishes and define the dish. Now, in this case we will use a new method called dishes create which takes, as a parameter, the newDish to create and then saves it in our application. So, instead of doing this newDish save, we can simply remove that and directly deal with the dishes create method here. So, the dishes create method will take as a parameter a new document that needs to be stored in our database, and then creates and adds the document to the database. Thereafter, we can continue with the rest of the exercise. This minor modification will show that the same application runs exactly the same way as before. So, with this change, let me just change the indentation here so that the chaining of the then methods is very clear. So, we first do a dishes create which will return a promise, and then change to the then and then we will carry out the remaining steps on the created dish. Let's save the changes and then go and take a look at this version of our server. Going to the terminal, once again, running the application, we see that it will create exactly the same as the previous variation of the server. So, we are creating a new dish here and then inserting it into the database and thereafter we are retrieving that dish and then printing out on the screen. With this change, this is a good time for us to do a git commit with the message Mongoose part two. So, let's check the git status and then add the file to the repository, and then do a git commit with the message Mongoose part two. Continuing with the exercise, in the next step we're going to add in a sub-document to the document and see how sub-documents can be stored in our database. So, going to dishes.js file, I'm going to add in another schema into my dishes.js file called as comment Schema and then define this as new Schema. In this comment schema, as you would have already expected, we're going to use this to store comments about the dish. So, the comments will contain a rating field which is of the type number, and its minimum value is one, maximum value is five and required is true. So, you can see that when you use a field with the type number, you can specify the boundaries for it if you choose to. Then the next field is a comment field which would be of the type string. So, this stores a message and then required is true and then we'll also add another field called author, which is of the type string and required is true. We will also add the timestamp field for this, and set that to true. So, for every comment that is added, we will also store the corresponding timestamp. So, now that we have declared a comment schema, we can then go ahead and modify the dish schema to be able to store comments. So, within the dishes schema, we can add in comments which is an array of the type comment schema, so which means that every dish object, dish document can have multiple comments stored within an array inside the dish document. So, this is the comment documents becomes sub-documents inside a dish document. So, we're storing all the comments about the dish inside the dish itself as an array of comment documents. So, this is the usage of the sub-document in Mongoose. After this, let's go to the index.js file and then modify our index.js file. In here, they create the dish just like before. Then after we create the dish, then we console log the dish. Thereafter, we will update the dish. So, we'll say dishes find by ID and update. So, we're going to modify the dish that we just inserted in the previous step. So, we'll say, "Find by ID and update." And we're going to supply. In this takes two parameters, the first parameter is the dish._id. Now, this dish._id of course refers to this dish that we have just inserted, and then we're going to modify that same dish in the next step. So, we'll say, "Dish._id." And then, within brackets, we specify $set, description, updated test and new true. So, this, we are modifying the dish that we have just inserted by updating its description there. Now, this has to be enclosed inside. This second flag that we are supplying here, new colon equal to true, means that once the update of the dish is complete, then this will return the dish, updated dish back to us. So, that's the reason for using this flag here, say, new true. So, this dish will be returned in the next step. And so, we're going to take that dish and then print out that dish. So, in the next step, we're going to modify this and say, "This, then dish." And then, we'll do a console log of dish. Then after this, we're going to insert a comment into the dish. So, we'll say, "Dish.comments.push." Recall that the comments is a field inside the dish. So, going back to the schema, we see that this comments is an array of the commentSchema type. So, which means that we can push an item into this array. So, going back here, we'll say, "Dish comments push." And then, we'll push a comment document into the dish here. So, I will say, "Dish comments push." And specify the fields here. So, we'll say, "Rating five, comment and author." And so, this will push this comment into the comment field of this specific dish. So, now that we have modified the dish, the next step that we're going to do is to, let me close off this and then put that into it, then there. I'm going to come back and fix that in a short while. So, now that we have modified the dish, we need to save the dish. So, we'll say, "Return dish safe." So, in this step, we are inserting a comment into the dish, the dish that we have just created and updated, and then we are saving that comment; and then, this will return the dish. And when the dish is returned in the next callback, I'm going to then say, "Console log dish." And then, after that, we will say, "Return." So, with this, we have modified our index.js file. Let's save the changes and look at this application. Going to the terminal, let's run npm start and then see the resulting value here. So, going back, we see that in the first step, we have created this dish here with the name and description as we have given earlier. And then, once the dish is created, in the second step, we updated the dish and then printed out the updated version of the dish. So, the updated version of the dish is printed out right there. And you can see that the description has been updated from the previous case, but the id remains exactly the same as the dish that we created earlier. And the comments field, as you can see here, is an empty array and the smoked. In third step, we push the comment into our dish here; and then so, this particular comment that we added has been added into this comments array. So, you can see that comment being enclosed here, and this is the updated dish that has now been printed onto the screen here. So, you can see that we have done several steps one after another with our dish. We first created the dish, then we updated the dish, then we inserted a comment into the dish, which is a sub-document inside the dish document; and then, we printed out the result to you. With this, we complete this exercise. In this exercise, we have seen how we can, first, create a dish by using dishes create, then we saw the use of sub-documents: there, we defined a schema within the dishes.js file and then use the comment schema that we defined and then defined the field in the dishes schema as an array of the commentSchema type. And then, in the index.js file, we were able to create a dish, update the dish and also push a comment document into the dish and then save the changes here. With this, we complete this exercise. This is a good time for you to do a Git Kermit with the message, "Mongoose part three."