In this lecture and the exercise that follows, we'll talk specifically about Callback Hell. The problem that arises when you write callbacks in node and especially nested callbacks and node. We'll also look at promises as one way of addressing the Callback Hell problem. To give you an idea of what the typical Callback Hell problem will result in, let's revisit the index.js file from the previous exercise. As I was talking about it in the previous exercise you notice that for each of the operations that we perform, the subsequent operation is included inside the callback function here and so on until you form a pyramid like structure go again. So you see this pyramid like structure arising within your code. Now imagine that you need to perform multiple nested operations like this, your code will become pretty soon, very complex, and not so easy to decipher. Now this is what in the node.js world, they refer to as Callback Hell. There have been several ways of mitigating the problem that arises. Now you can completely avoid this because of the fact that you have certain operations that need to complete before the next operation can be initiated, but we can rearrange the code in a way to mitigate this problem. Promises being one such way of addressing this. So to summarize what we have just discussed, heavily nested callback code, causes the Callback Hell problem and it results from our tendency to write programs top-down. We are still hung up with our sequential way of writing code and so we see it more convenient to write code top to bottom, and look at it as if it is executing in that order. Now we can work around the Callback Hell problem by not using anonymous functions for the callbacks but instead, declaring those functions with specific names, and then avoid the way we write the code as you saw here. That is one of the approaches that people take to deal with the Callback Hell problem. There are several other approaches that have been suggested, links to a couple of articles in this regard are provided in the additional resources. But in this particular lecture, I will concentrate on one particular approach that is used to deal with for the Callback Hell problem, that is the use of promises. So we can use promises to tame the Callback Hell problem to quite an extent. We will look at how promises help us in this regard and in the exercise we will see how because the NODE-MONGO DB driver already supports a proxy interface we can leverage that to rewrite our code to take advantage of promise support in the MONGO DB driver. Briefly summarizing what a promise is. A promise is a mechanism that supports asynchronous computation. So if you have amount of work that needs to be done, the promise acts as a proxy for a value which is not known at the moment but the promise is given to you. But when the value becomes available, it will be available in the future. So the promise represents a placeholder for that value. If the value results correctly, then your promise results correctly and you can have a piece of code execute in order to handle the fact that the promise resolved correctly, if not then you handle the error in that situation. So, a promise will resolve either into resolve or the rejection of the promise. A pending promise might either resolve when the value is correctly obtained so in that case, it will resolve or what we call as the fulfilling of the promise. So when the promise is resolved, then you will have a piece of code that handles the fact that the promise has been resolved. If the promise is rejected, you should also handle that situation the rejection of the promise correspondingly within your code. So that is the reason whenever you create a promise, you only supply the resolve and the reject options from it. The resolve option is typically handled by the doctor then option for your promise. So why do we use promises? Promises are used because it addresses the callback hell problem to a large extent and promises can be changed. For example, if you have one promise which in turn triggers a call to another one which will return a promise. The handling of the promise can be changed to the handle of the previous promise. So you can have a bunch of, then calls that will handle the return of the value. Now we will see the use of this in the exercise that follows this lecture. To consume a promise, you will register an appropriate callback function for when the consumer of a promise is notified either of the fulfillment or the rejection of the promise. So the callbacks are registered through the.then() to the promise. You will use the.catch() to catch the errors within the return promise. Now the.then() methods can be chained together as you will see in the exercise that follows. As an example, you would normally handle a promise by chaining the.then() and the.catch() to the promise value.