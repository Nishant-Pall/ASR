In this exercise, we will continue with the previous exercise where we developed the interaction between the node application and the MongoDB server. In this exercise, I am going to encapsulate a few of the database operations into a node module of its own, a file-based node module, and then make use of it within my node application in order to interact with the server. At the same time, we'll perform several operations on the server to demonstrate that we will be able to interact with the server using our node application and the node MongoDB driver. To get started, let's go to our project, and then create a new file named operations.js. This file will encapsulate all that database operations, the four operations that I'm going to perform insert, find, remove and update a document in my database. Now, this will be organized as a file-based node module, which then I will make use of it in my node application to access the server. So, to get started, let me first require assert, in this node module, and since this happens to be a node module, we'll be exporting several methods from the node module. The first method would be insert document obviously as you would expect, and this will take four parameters DB, the MongoDB, database connection within my node application, that I will obtain within the node application. Then the second one is the document which I want to insert. The third parameter is the collection into which I want to insert the document. The last one is a callback function, which will be called back once that operation is completed. Then let's close the function here, and this essentially encapsulates the insert document method here. So, this is a function which is exported by this node module here. Now, I'm going to also incorporate a few more methods here. The second one would be finddocuments. Not just one but several documents. This I would search the collection and find all the documents that are in the collection. So, that's why I'm only taking the database and the collection as the two parameters along with the callback. The third function that I'm going to implement an export from here is the removedocument. This supports the delete operation, and so the name of document will take the database, the document, the collection and the callback as the four parameters, and we'll call the callback when the operation is completed. The final one of course is to update the document. Now of course, you don't necessarily have to do it this way. I just felt that this would be another way of illustrating how you can encapsulate that functions into its own node module. This is just reorganizing the code in a way that is more easier to use. So, for the exports, for the update document it takes the DB, some way of identifying the document as a second parameter. The third parameter is the update, and the fourth parameter is the collection in which this document exists, and the callback. So, four functions to be exported by the operations.js file. Now, within this functions, let's implement one by one. In the insert document, the first thing that I'm going to do is say const collection and it'll say DB collection, and the parameter is the collection. So, we'll look for the collection there. Now, this has to be performed in all the four methods. So, I'm going to go and paste this code into all the four methods here, because that's a function that I need in all of them. So, once I get hold of the collection, then as you recall from the previous exercise, I can perform operations on the collection. So, I'll say collection, insert, and this takes as the first parameter the document to be inserted, and the second parameter is the callback with the error and that result. So, now when this document is inserted by calling the insert method on the database collection, the insert method let me remind you, is supported by the MongoDB driver. So, that's the method that we're using here, or that's the function that we're using here. Now, the first thing that I'm going to check for this, assertequal err, null. So, I want to make sure that I don't have an error. So I want to make sure that the error is null. If it is not null, then this will print out the information and then quit the application. At this moment, I feel that this is okay to handle it that later on, we'll see how we can have a global way of handling all the errors when we implement in the next lesson another way of accessing the MongoDB database. Now, after I do this, I'm going to implement, I'm going to simply log this information. So I'll say, console log and insert it. So, this information will be printed out to the screen here, inserted. Now again, remember the semicolons and all that are important don't forget them when you are typing in your code. So, I'll say inserted result. This result object that is returned, will have on it a property called the result property, and this property will contain a value. This result property is also a JavaScript object, and this will contain a property n which tells us how many documents have been inserted. So that's the information that I'm going to print out here, and then we'll go to the next line and say "documents into the collection." Now, this is just a way of informing the user that this operation took place correctly, and then they will pass that result back to our calling function. So, we'll call the callback and then the result will be the parameter to the callback. So, when we implement the usage of this function in our index.js file, we will be providing the callback there which will receive the result as the incoming parameter. So, this is for the "insertDocument." Now, for the "findDocument, " what I am going to do is to say, "coll.find" and I'm going to find all the documents. So, that's why I will give an empty JavaScript object in here, which will match with all the documents in the collection and then I'll say, "toArray" and this will take as a parameter a callback function, and inside this callback function, of course, I will assert that this is not null, and then we will say, "callback docs." We'll simply pass back the retrieved documents back to the calling function. Now, for the "removeDocument," I'm going to say, "collection deleteOne." So, I'll try to find the first document that matches what we have specified and then delete it. And then this will take, again, a callback function as a second parameter, and inside this callback function, the first thing that I check is to make sure that the error is not null. And then after that, we will say, "console log removed the document comma document." We used the comma here because this is a JavaScript object so, if you specify console log like this, the document will be printed out and then we'll pass that result back through the callback function. And then finally, for the update we'll coll.updateOne. This is a method the MongoDB driver supports. So, I'll say, "update.One document, " and the second parameter is where we will pass in the fields that need to be updated. And the way it is done, we'll say, "dollar set colon update." So, this will take the update information that I'm sending in and then pass it into the update.One. The first one is the document that needs to be updated. The second one is which fields of the document needs to be updated here. And the third parameter is null, and that last parameter is a callback function, which obviously will give us the result of the operation. So, first thing I'm going to check to make sure that the error is not null. Then, I'll do a "console log updated the document with." Now again, the console logs are purely for us to ensure that the code is doing what it is doing. It doesn't help in any way. This is just for our own information. In a production server, you would not be having this console logs, maybe. You can disable them. So, that's it. So four methods being supported in this particular file-based node module insert, find, remove and update. So, now that we have implemented this file-based node module, let's go to the index.js file, and then to make use of that file-based node module, I need to require this here. So, I'll say, "const dboper require." Since this is a file-based node module you get the full path to the node module, and which in this case happens to be./operations because it is in the same folder as my index.js file. Now, once we have done this, then right here, this function, this code that we were doing to access the database now insert, we will be using the dboper that we have just implemented to access that database. So, we'll say, "dboper insert document, " and this "insert document" takes the db as the first parameter. The db here, is this db that came in when we call MongoClient connect. So that db will be passed in, so that way, my operations node module knows where to access the database. Then the second parameter is the, so if you look at the "insert document" you will see that the second parameter is the document to be inserted. So, I will say, "name. " I'm just going to construct a JSON object or JavaScript object here, which will automatically be mapped into adjacent object when it is being inserted. And the third parameter, as you see, "db document collection and callback." So the third parameter is the collection and the collection is the dishes collection and the final one is the callback. The call back again as you recall receives the result. If you look back at the baby implemented the insert document, the callback received the result as the parameter. So inside this callback we will handle that result value here. So, when the result value comes in we'll do a console.log. We'll say insert document backslash N and we'll say result OPS. The OPS tells you the number of insert operations that were carried out. So this is another object that is going to be on the result JavaScript object that is passed back in as the parameter and so I'm just going to print out that value. So that'll give us some information about what has happened. Now once this is completed, inside this callback function I'm going to call the next database operation. So I'll say dboper and then find the documents. Then I'll say dbdishes and the third parameter is docs, which is the callback function. When I receive the docs I'm going to do a console.log saying found documents, and we'll simply lock the documents to the screen. So, this will print out the found documents. Notice that this call is inside the callback function that is applied for the earlier function call, so that is something that I want you to notice specifically. Now, again inside this function call they need to do it this way because until this callback is called we cannot do the next operation. So, in that next operation I'm going to update the document that I have just inserted. So I will say update the document and I'll say Update Document DB, and then the next parameter is the document and I don't need to specify the entire document I can only specify one field and then that'll find the document that matches this particular field. What I'm going to do is the next parameter is the update that needs to be supplied. So, the update is which field I want to update, so I'm going to update the description field by saying Updated Test, and then the fourth one is the collection which is Dishes, and the final one is the callback function which obtains the docs as the return value or rather result of the update operation that we just carried out. Then inside this callback function, I'm going to again do a console.log saying updated document backslash N. The updated document will be passed back in result.result on this property of the result object that is passed tracking. Again notice how the calls are getting nested inside the callback functions here. I want you to notice this structure of the code specifically because that is what I'm going to come back to in the next exercise. Now after I do that, I'm going to find the documents, so let me just copy that and then I'm going to use the same code here. So I will say, find documents. Inside here I am again going to say, found updated document. Then finally when I'm done with this, I will simply call db drop collection. So I'm going to delete this dishes collection so that I will clean up my database so that I don't have anything more because for the next exercise I want to clean up the database and then start with a cleaner database. So, I'm going to clean out the dishes collection and then this would result in a callback. So inside here I'm going to do a console.log saying, dropped collection, and then I'll just print out the result that came in. Then finally, close the database. Note that structure of the code, DB insert document and inside the callback function I'm going to call the next function and inside the callback off that I'm going to call the next function and inside the callback next function and so on. So, you see a nested set of callbacks here and a tree structured nested set of call backs here. That is something that I want you to pay attention to. Let's save the changes and go and look at this version of our application. Getting back to the terminal, let me execute the application. So let me type NPM start and we'll see that result. Now, from this result you can see that the document is inserted into the collection and that is the document that has been found. In the second step, we are finding the document so when we call the DB find document, so this is the document that is retrieved from my collection. Then I ask it to update the document with this and then you'll notice that it says updated document and then here it prints the result or OPS and it says N is equal to one number modified as one and it was okay. Then it prints out the updated document, we find the updated document here and that is what is printed out here, and note in particular that the description has been updated. Then finally, it dropped the collection. So we see how this application runs and is able to make use of the node module that we implemented and then performed various database operations. With this we complete this exercise. In this exercise I have demonstrated to you how you would interact with your MongoDB server from your node application. We have implemented our own node module here and then used it within our node application by encapsulating certain of the database operations into that node module. This is a good time for you to do a Git commit with the message node MongoDB example part two.